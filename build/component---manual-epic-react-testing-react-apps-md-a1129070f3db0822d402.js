(window.webpackJsonp=window.webpackJsonp||[]).push([[247],{gfME:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return a})),n.d(t,"default",(function(){return l}));n("1c7q"),n("abGl"),n("gZHo"),n("Fdmb"),n("Ir+3"),n("2mQt"),n("mXGw");var r=n("/FXl"),o=n("TjRS");n("aD51");function s(){return(s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var a={};void 0!==a&&a&&a===Object(a)&&Object.isExtensible(a)&&!a.hasOwnProperty("__filemeta")&&Object.defineProperty(a,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"manual/Epic-React/Testing-React-Apps.md"}});var i={_frontmatter:a},c=o.a;function l(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,["components"]);return Object(r.b)(c,s({},i,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"testing-react-apps"},"Testing React Apps"),Object(r.b)("h2",{id:"simple-test-with-reactdom"},"Simple Test with ReactDOM"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},'"The more your tests resemble the way your software is used, the more\nconfidence they can give you." -\n',Object(r.b)("a",s({parentName:"p"},{href:"https://twitter.com/kentcdodds/status/977018512689455106"}),"@kentcdodds"))),Object(r.b)("p",null,"To just get a basic component logging to our terminal during a test, we can have:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"import * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport Counter from '../../components/counter';\n\ntest('counter increments and decrements when the buttons are clicked', () => {\n  // ğŸ¨ create a div to render your component to (ğŸ’° document.createElement)\n  const div = document.createElement('div');\n  // ğŸ¨ append the div to document.body (ğŸ’° document.body.append)\n  document.body.append(div);\n  // ğŸ¨ use ReactDOM.render to render the <Counter /> to the div\n  ReactDOM.render(<Counter />, div);\n  console.log(document.body.innerHTML);\n});\n")),Object(r.b)("p",null,"To start validating messages from the div we created, we could do the following (for the example of the counter with a single text element):"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// simple test with ReactDOM\n// http://localhost:3000/counter\n\nimport * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport Counter from '../../components/counter';\n\ntest('counter increments and decrements when the buttons are clicked', () => {\n  // ğŸ¨ create a div to render your component to (ğŸ’° document.createElement)\n  const div = document.createElement('div');\n  // ğŸ¨ append the div to document.body (ğŸ’° document.body.append)\n  document.body.append(div);\n  // ğŸ¨ use ReactDOM.render to render the <Counter /> to the div\n  ReactDOM.render(<Counter />, div);\n\n  // ğŸ¨ get a reference to the message div:\n  const message = div.firstChild.querySelector('div');\n  //\n  // ğŸ¨ expect the message.textContent toBe 'Current count: 0'\n  expect(message.textContent).toBe('Current count: 0');\n});\n")),Object(r.b)("p",null,"To now test the clicking of the buttons, we can do the following:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// simple test with ReactDOM\n// http://localhost:3000/counter\n\nimport * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport Counter from '../../components/counter';\n\ntest('counter increments and decrements when the buttons are clicked', () => {\n  // ğŸ¨ create a div to render your component to (ğŸ’° document.createElement)\n  const div = document.createElement('div');\n  // ğŸ¨ append the div to document.body (ğŸ’° document.body.append)\n  document.body.append(div);\n  // ğŸ¨ use ReactDOM.render to render the <Counter /> to the div\n  ReactDOM.render(<Counter />, div);\n  // ğŸ¨ get a reference to the increment and decrement buttons:\n  const [decrement, increment] = div.querySelectorAll('button');\n\n  // ğŸ¨ get a reference to the message div:\n  //   ğŸ’° div.firstChild.querySelector('div')\n  const message = div.firstChild.querySelector('div');\n  //\n  // ğŸ¨ expect the message.textContent toBe 'Current count: 0'\n  expect(message.textContent).toBe('Current count: 0');\n  // ğŸ¨ click the increment button (ğŸ’° increment.click())\n  increment.click();\n  // ğŸ¨ assert the message.textContent\n  expect(message.textContent).toBe('Current count: 1');\n  // ğŸ¨ click the decrement button (ğŸ’° decrement.click())\n  decrement.click();\n  // ğŸ¨ assert the message.textContent\n  expect(message.textContent).toBe('Current count: 0');\n  //\n  // ğŸ¨ cleanup by removing the div from the page (ğŸ’° div.remove())\n  // ğŸ¦‰ If you don't cleanup, then it could impact other tests and/or cause a memory leak\n  div.remove();\n});\n")),Object(r.b)("p",null,"But instead of ",Object(r.b)("inlineCode",{parentName:"p"},"div.remove"),", it is better for us to set a before hook. The reason being that if a test fails, it could cause subsequent failures at the clean up did not occur."),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"beforeEach(() => (document.body.innerHTML = ''));\n")),Object(r.b)("h3",{id:"use-dispatchevent"},"Use dispatchEvent"),Object(r.b)("p",null,"To follow more closely with what happens when the user clicks in React, we change to use ",Object(r.b)("inlineCode",{parentName:"p"},"dispatchEvent"),":"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// simple test with ReactDOM\n// http://localhost:3000/counter\n\nimport * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport Counter from '../../components/counter';\n\nbeforeEach(() => (document.body.innerHTML = ''));\n\ntest('counter increments and decrements when the buttons are clicked', () => {\n  // ğŸ¨ create a div to render your component to (ğŸ’° document.createElement)\n  const div = document.createElement('div');\n  // ğŸ¨ append the div to document.body (ğŸ’° document.body.append)\n  document.body.append(div);\n  // ğŸ¨ use ReactDOM.render to render the <Counter /> to the div\n  ReactDOM.render(<Counter />, div);\n  // ğŸ¨ get a reference to the increment and decrement buttons:\n  const [decrement, increment] = div.querySelectorAll('button');\n\n  const incrementClickEvent = new MouseEvent('click', {\n    // required for event delgation to work (required by React)\n    bubbles: true,\n    cancelable: true,\n    button: 0,\n  });\n\n  const decrementClickEvent = new MouseEvent('click', {\n    // required for event delgation to work (required by React)\n    bubbles: true,\n    cancelable: true,\n    button: 0,\n  });\n\n  // ğŸ¨ get a reference to the message div:\n  //   ğŸ’° div.firstChild.querySelector('div')\n  const message = div.firstChild.querySelector('div');\n  //\n  // ğŸ¨ expect the message.textContent toBe 'Current count: 0'\n  expect(message.textContent).toBe('Current count: 0');\n  increment.dispatchEvent(incrementClickEvent);\n  // ğŸ¨ assert the message.textContent\n  expect(message.textContent).toBe('Current count: 1');\n  // ğŸ¨ click the decrement button (ğŸ’° decrement.click())\n  decrement.dispatchEvent(decrementClickEvent);\n  // ğŸ¨ assert the message.textContent\n  expect(message.textContent).toBe('Current count: 0');\n  //\n  // ğŸ¨ cleanup by removing the div from the page (ğŸ’° div.remove())\n  // ğŸ¦‰ If you don't cleanup, then it could impact other tests and/or cause a memory leak\n  div.remove();\n});\n")),Object(r.b)("h2",{id:"simple-test-with-react-testing-library"},"Simple Test With React Testing Library"),Object(r.b)("p",null,"Liked the above example, but did not enjoy the boilerplate. Implementing ",Object(r.b)("inlineCode",{parentName:"p"},"react-testing-library")," looks like so:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// simple test with React Testing Library\n// http://localhost:3000/counter\n\nimport * as React from 'react';\n// ğŸ¨ import the `render` and `fireEvent` utilities from '@testing-library/react'\nimport { render, fireEvent } from '@testing-library/react';\nimport Counter from '../../components/counter';\n\ntest('counter increments and decrements when the buttons are clicked', () => {\n  // ğŸ¨ swap ReactDOM.render with React Testing Library's render\n  // Note that React Testing Library's render doesn't need you to pass a `div`\n  // so you only need to pass one argument. render returns an object with a\n  // bunch of utilities on it. For now, let's just grab `container` which is\n  // the div that React Testing Library creates for us.\n  const { container } = render(<Counter />);\n\n  // ğŸ¨ instead of `div` here you'll want to use the `container` you get back\n  // from React Testing Library\n  const [decrement, increment] = container.querySelectorAll('button');\n  const message = container.firstChild.querySelector('div');\n\n  expect(message.textContent).toBe('Current count: 0');\n\n  // ğŸ¨ replace the next two statements with `fireEvent.click(button)`\n  fireEvent.click(increment);\n  expect(message.textContent).toBe('Current count: 1');\n  fireEvent.click(decrement);\n  expect(message.textContent).toBe('Current count: 0');\n});\n")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"One of the slight differences is that fireEvent is automatically wrapped in ReactTestUtils act() function. If you ever see an act warning, then that's absolutely something that you probably need to deal with, but you never need to wrap a call to fireEvent in act.\nThe only reason I'm mentioning that to you is because I see it all the time. If you ever come across an act warning, your solution is not to wrap the fireEvent call in act. The solution will be something else entirely.")),Object(r.b)("h3",{id:"using-jest-dom-for-better-messages"},"Using jest-dom for better messages"),Object(r.b)("p",null,"We can import ",Object(r.b)("inlineCode",{parentName:"p"},"@testing-library/jest-dom")," into the file (or in a setup file) to extend our Jest assertions to include things such as ",Object(r.b)("inlineCode",{parentName:"p"},".toHaveTextContent")," for better error messaging. Once done we can update our code to look like so:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// simple test with React Testing Library\n// http://localhost:3000/counter\n\nimport * as React from 'react';\n// ğŸ¨ import the `render` and `fireEvent` utilities from '@testing-library/react'\nimport { render, fireEvent } from '@testing-library/react';\nimport Counter from '../../components/counter';\n\ntest('counter increments and decrements when the buttons are clicked', () => {\n  // ğŸ¨ swap ReactDOM.render with React Testing Library's render\n  // Note that React Testing Library's render doesn't need you to pass a `div`\n  // so you only need to pass one argument. render returns an object with a\n  // bunch of utilities on it. For now, let's just grab `container` which is\n  // the div that React Testing Library creates for us.\n  const { container } = render(<Counter />);\n\n  // ğŸ¨ instead of `div` here you'll want to use the `container` you get back\n  // from React Testing Library\n  const [decrement, increment] = container.querySelectorAll('button');\n  const message = container.firstChild.querySelector('div');\n\n  expect(message).toHaveTextContent('Current count: 0');\n\n  // ğŸ¨ replace the next two statements with `fireEvent.click(button)`\n  fireEvent.click(increment);\n  expect(message).toHaveTextContent('Current count: 1');\n  fireEvent.click(decrement);\n  expect(message).toHaveTextContent('Current count: 0');\n});\n")),Object(r.b)("h2",{id:"avoid-implementation-details"},"Avoid Implementation Details"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"The implementation of your abstractions does not matter to the users of your abstraction and if you want to have confidence that it continues to work through refactors then ",Object(r.b)("strong",{parentName:"p"},"neither should your tests."))),Object(r.b)("p",null,"Here's a React example of this:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-javascript"}),"function Counter() {\n  const [count, setCount] = React.useState(0);\n  const increment = () => setCount(c => c + 1);\n  return <button onClick={increment}>{count}</button>;\n}\n")),Object(r.b)("p",null,"Here's one way you might access that ",Object(r.b)("inlineCode",{parentName:"p"},"button")," to click and assert on it:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-javascript"}),"const { container } = render(<Counter />);\ncontainer.firstChild; // <-- that's the button\n")),Object(r.b)("p",null,"However, what if we changed it a bit:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-javascript"}),"function Counter() {\n  const [count, setCount] = React.useState(0);\n  const increment = () => setCount(c => c + 1);\n  return (\n    <span>\n      <button onClick={increment}>{count}</button>\n    </span>\n  );\n}\n")),Object(r.b)("p",null,"Our tests would break!"),Object(r.b)("p",null,"The only difference between these implementations is one wraps the button in a\n",Object(r.b)("inlineCode",{parentName:"p"},"span")," and the other does not. The user does not observe or care about this\ndifference, so we should write our tests in a way that passes in either case."),Object(r.b)("p",null,"So here's a better way to search for that button in our test that's\nimplementation detail free and refactor friendly:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-javascript"}),"render(<Counter />);\nscreen.getByText('0'); // <-- that's the button\n// or (even better) you can do this:\nscreen.getByRole('button', { name: '0' }); // <-- that's the button\n")),Object(r.b)("p",null,"In the example, we did the following change:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// Avoid implementation details\n// INITIAL CODE\n\nimport * as React from 'react';\n// ğŸ¨ add `screen` to the import here:\nimport { render, fireEvent } from '@testing-library/react';\nimport Counter from '../../components/counter';\n\ntest('counter increments and decrements when the buttons are clicked', () => {\n  const { container } = render(<Counter />);\n  // ğŸ¨ replace these with screen queries\n  // ğŸ’° you can use `getByText` for each of these (`getByRole` can work for the button too)\n  const [decrement, increment] = container.querySelectorAll('button');\n  const message = container.firstChild.querySelector('div');\n\n  expect(message).toHaveTextContent('Current count: 0');\n  fireEvent.click(increment);\n  expect(message).toHaveTextContent('Current count: 1');\n  fireEvent.click(decrement);\n  expect(message).toHaveTextContent('Current count: 0');\n});\n\n// Avoid implementation details\n// FIRST CHANGE\n\nimport * as React from 'react';\n// ğŸ¨ add `screen` to the import here:\nimport { render, fireEvent, screen } from '@testing-library/react';\nimport Counter from '../../components/counter';\n\ntest('counter increments and decrements when the buttons are clicked', () => {\n  render(<Counter />);\n  // ğŸ¨ replace these with screen queries\n  const decrement = screen.getByText('Decrement');\n  const increment = screen.getByText('Increment');\n  const message = screen.getByText('Current count: 0');\n\n  expect(message).toHaveTextContent('Current count: 0');\n  fireEvent.click(increment);\n  expect(message).toHaveTextContent('Current count: 1');\n  fireEvent.click(decrement);\n  expect(message).toHaveTextContent('Current count: 0');\n});\n\n// Avoid implementation details\n// FINAL CHANGE\n\nimport * as React from 'react';\n// ğŸ¨ add `screen` to the import here:\nimport { render, fireEvent, screen } from '@testing-library/react';\nimport Counter from '../../components/counter';\n\ntest('counter increments and decrements when the buttons are clicked', () => {\n  render(<Counter />);\n  // ğŸ¨ replace these with screen queries\n  const decrement = screen.getByRole('button', { text: /decrement/i });\n  const increment = screen.getByRole('button', { text: /increment/i });\n  const message = screen.getByText(/current count/i);\n\n  expect(message).toHaveTextContent('Current count: 0');\n  fireEvent.click(increment);\n  expect(message).toHaveTextContent('Current count: 1');\n  fireEvent.click(decrement);\n  expect(message).toHaveTextContent('Current count: 0');\n});\n")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"screen")," utility can be used to find computations based on attributes that can found using the ",Object(r.b)("inlineCode",{parentName:"p"},"accessibility")," tab."),Object(r.b)("p",null,"There is information on priority for testing implementation details that can be found ",Object(r.b)("a",s({parentName:"p"},{href:"https://testing-library.com/docs/queries/about/"}),"here"),"."),Object(r.b)("h3",{id:"browser-events-handling-more-than-just-a-click"},"Browser events (handling more than just a click)"),Object(r.b)("p",null,"If the implementation detail is changed for the event that fires it (by is a subtle relation to a click), our tests will break. To be resilient to this (or to test similar interactions) then we can do the following:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// Avoid implementation details\n// http://localhost:3000/counter\n\nimport * as React from 'react';\n// ğŸ¨ add `screen` to the import here:\nimport { render, userEvent, screen } from '@testing-library/react';\nimport Counter from '../../components/counter';\n\ntest('counter increments and decrements when the buttons are clicked', () => {\n  render(<Counter />);\n  // ğŸ¨ replace these with screen queries\n  const decrement = screen.getByRole('button', { text: /decrement/i });\n  const increment = screen.getByRole('button', { text: /increment/i });\n  const message = screen.getByText(/current count/i);\n\n  expect(message).toHaveTextContent('Current count: 0');\n  userEvent.click(increment);\n  expect(message).toHaveTextContent('Current count: 1');\n  userEvent.click(decrement);\n  expect(message).toHaveTextContent('Current count: 0');\n});\n")),Object(r.b)("p",null,"All we need to change is ",Object(r.b)("inlineCode",{parentName:"p"},"fireEvent")," to ",Object(r.b)("inlineCode",{parentName:"p"},"userEvent"),". When running ",Object(r.b)("inlineCode",{parentName:"p"},"click")," with a ",Object(r.b)("inlineCode",{parentName:"p"},"userEvent"),", it will fire all kinds of events for us to test these different scenarions that a user may make."),Object(r.b)("h2",{id:"form-testing"},"Form Testing"),Object(r.b)("p",null,"To test our form, we can first debug what is on the screen to render our the current HTML from the component that is rendered:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// form testing\n// http://localhost:3000/login\n\nimport * as React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Login from '../../components/login';\n\ntest('submitting the form calls onSubmit with username and password', () => {\n  render(<Login />);\n  screen.debug();\n});\n")),Object(r.b)("p",null,"We can assert that our form works as expected by updating the code to the following:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// form testing\n// http://localhost:3000/login\n\nimport * as React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Login from '../../components/login';\n\ntest('submitting the form calls onSubmit with username and password', () => {\n  let submittedData;\n  const handleSubmit = data => (submittedData = data);\n  render(<Login onSubmit={handleSubmit} />);\n  const username = 'chucknorris';\n  const password = 'i need no password';\n\n  userEvent.type(screen.getByLabelText(/username/i), username);\n  userEvent.type(screen.getByLabelText(/password/i), password);\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n\n  expect(submittedData).toEqual({\n    username,\n    password,\n  });\n});\n")),Object(r.b)("h3",{id:"using-a-jest-mock-function"},"Using a Jest Mock function"),Object(r.b)("p",null,"This is us listening and assert what the ",Object(r.b)("inlineCode",{parentName:"p"},"onSubmit")," function call is passed and how many times it is fired:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// form testing\n// ğŸ’¯ use a jest mock function\n// http://localhost:3000/login\n\nimport * as React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Login from '../../components/login';\n\ntest('submitting the form calls onSubmit with username and password', () => {\n  const handleSubmit = jest.fn();\n  render(<Login onSubmit={handleSubmit} />);\n  const username = 'chucknorris';\n  const password = 'i need no password';\n\n  userEvent.type(screen.getByLabelText(/username/i), username);\n  userEvent.type(screen.getByLabelText(/password/i), password);\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n\n  expect(handleSubmit).toHaveBeenCalledWith({\n    username,\n    password,\n  });\n  expect(handleSubmit).toHaveBeenCalledTimes(1);\n});\n")),Object(r.b)("h3",{id:"generate-test-data"},"Generate test data"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"\"Something to keep in mind is that people are going to be reading this test in the future. They may not know the implementation of login and what decisions were made and what's important. Everything that they see in the test, they're going to assume it's important. They're going to assume that it's important that we render the login with an onSubmit prop.\"")),Object(r.b)("p",null,"We can use Faker to help the user know that the implementation value is not important."),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// form testing\n// ğŸ’¯ generate test data\n// http://localhost:3000/login\n\nimport * as React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport faker from 'faker';\nimport Login from '../../components/login';\n\nfunction buildLoginForm() {\n  return {\n    username: faker.internet.userName(),\n    password: faker.internet.password(),\n  };\n}\n\ntest('submitting the form calls onSubmit with username and password', () => {\n  const handleSubmit = jest.fn();\n  render(<Login onSubmit={handleSubmit} />);\n  const { username, password } = buildLoginForm();\n\n  userEvent.type(screen.getByLabelText(/username/i), username);\n  userEvent.type(screen.getByLabelText(/password/i), password);\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n\n  expect(handleSubmit).toHaveBeenCalledWith({\n    username,\n    password,\n  });\n  expect(handleSubmit).toHaveBeenCalledTimes(1);\n});\n")),Object(r.b)("h3",{id:"allow-for-overrides"},"Allow for overrides"),Object(r.b)("p",null,"We just allow overrides so that a user can handle special cases."),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// form testing\n// ğŸ’¯ allow for overrides\n// http://localhost:3000/login\n\nimport * as React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport faker from 'faker';\nimport Login from '../../components/login';\n\n// overrides is the important part\nfunction buildLoginForm(overrides) {\n  return {\n    username: faker.internet.userName(),\n    password: faker.internet.password(),\n    ...overrides,\n  };\n}\n\ntest('submitting the form calls onSubmit with username and password', () => {\n  const handleSubmit = jest.fn();\n  render(<Login onSubmit={handleSubmit} />);\n  const { username, password } = buildLoginForm();\n\n  userEvent.type(screen.getByLabelText(/username/i), username);\n  userEvent.type(screen.getByLabelText(/password/i), password);\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n\n  expect(handleSubmit).toHaveBeenCalledWith({\n    username,\n    password,\n  });\n  expect(handleSubmit).toHaveBeenCalledTimes(1);\n});\n")),Object(r.b)("h3",{id:"use-test-data-bot"},"Use Test Data Bot"),Object(r.b)("p",null,"This is using a test data bot utility ",Object(r.b)("inlineCode",{parentName:"p"},"@jackfranklin/test-data-bot")," to help create test factories that can automatically be overriden."),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// form testing\n// ğŸ’¯ use Test Data Bot\n// http://localhost:3000/login\n\nimport * as React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { build, fake } from '@jackfranklin/test-data-bot';\nimport Login from '../../components/login';\n\nconst buildLoginForm = build({\n  fields: {\n    username: fake(f => f.internet.userName()),\n    password: fake(f => f.internet.password()),\n  },\n});\n\ntest('submitting the form calls onSubmit with username and password', () => {\n  const handleSubmit = jest.fn();\n  render(<Login onSubmit={handleSubmit} />);\n  const { username, password } = buildLoginForm();\n\n  userEvent.type(screen.getByLabelText(/username/i), username);\n  userEvent.type(screen.getByLabelText(/password/i), password);\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n\n  expect(handleSubmit).toHaveBeenCalledWith({\n    username,\n    password,\n  });\n  expect(handleSubmit).toHaveBeenCalledTimes(1);\n});\n")),Object(r.b)("h2",{id:"mocking-http-requests"},"Mocking HTTP Requests"),Object(r.b)("p",null,"We use ",Object(r.b)("inlineCode",{parentName:"p"},"msw")," to intercept web requests."),Object(r.b)("p",null,"We setup the server like so:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"const server = setupServer(\n  rest.post(\n    'https://auth-provider.example.com/api/login',\n    async (req, res, ctx) => {\n      if (!req.body.password) {\n        return res(ctx.status(400), ctx.json({ message: 'password required' }));\n      }\n      if (!req.body.username) {\n        return res(ctx.status(400), ctx.json({ message: 'username required' }));\n      }\n      return res(ctx.json({ username: req.body.username }));\n    },\n  ),\n);\n\nbeforeAll(() => server.listen());\nafterAll(() => server.close());\n")),Object(r.b)("p",null,"The code provided can handle the route to intercept along with the return values."),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// mocking HTTP requests\n// http://localhost:3000/login-submission\n\nimport * as React from 'react';\nimport {\n  render,\n  screen,\n  waitForElementToBeRemoved,\n} from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { build, fake } from '@jackfranklin/test-data-bot';\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\nimport Login from '../../components/login-submission';\n\nconst buildLoginForm = build({\n  fields: {\n    username: fake(f => f.internet.userName()),\n    password: fake(f => f.internet.password()),\n  },\n});\n\nconst server = setupServer(\n  rest.post(\n    'https://auth-provider.example.com/api/login',\n    async (req, res, ctx) => {\n      if (!req.body.password) {\n        return res(ctx.status(400), ctx.json({ message: 'password required' }));\n      }\n      if (!req.body.username) {\n        return res(ctx.status(400), ctx.json({ message: 'username required' }));\n      }\n      return res(ctx.json({ username: req.body.username }));\n    },\n  ),\n);\n\nbeforeAll(() => server.listen());\nafterAll(() => server.close());\n\ntest(`logging in displays the user's username`, async () => {\n  render(<Login />);\n  const { username, password } = buildLoginForm();\n\n  userEvent.type(screen.getByLabelText(/username/i), username);\n  userEvent.type(screen.getByLabelText(/password/i), password);\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n\n  await waitForElementToBeRemoved(() => screen.getByLabelText(/loading/i));\n\n  expect(screen.getByText(username)).toBeInTheDocument();\n});\n")),Object(r.b)("h3",{id:"mocked-responses"},"Mocked Responses"),Object(r.b)("p",null,"Essentially here we are abstracting the handlers to another file."),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// test/server-handlers.js\nimport { rest } from 'msw';\n\nconst delay = process.env.NODE_ENV === 'test' ? 0 : 1500;\n\nconst handlers = [\n  rest.post(\n    'https://auth-provider.example.com/api/login',\n    async (req, res, ctx) => {\n      if (!req.body.password) {\n        return res(\n          ctx.delay(delay),\n          ctx.status(400),\n          ctx.json({ message: 'password required' }),\n        );\n      }\n      if (!req.body.username) {\n        return res(\n          ctx.delay(delay),\n          ctx.status(400),\n          ctx.json({ message: 'username required' }),\n        );\n      }\n      return res(ctx.delay(delay), ctx.json({ username: req.body.username }));\n    },\n  ),\n];\n\nexport { handlers };\n")),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// mocking HTTP requests\n// ğŸ’¯ reuse server request handlers\n// http://localhost:3000/login-submission\n\nimport * as React from 'react';\nimport {\n  render,\n  screen,\n  waitForElementToBeRemoved,\n} from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { build, fake } from '@jackfranklin/test-data-bot';\nimport { setupServer } from 'msw/node';\nimport { handlers } from 'test/server-handlers';\nimport Login from '../../components/login-submission';\n\nconst buildLoginForm = build({\n  fields: {\n    username: fake(f => f.internet.userName()),\n    password: fake(f => f.internet.password()),\n  },\n});\n\nconst server = setupServer(...handlers);\n\nbeforeAll(() => server.listen());\nafterAll(() => server.close());\n\ntest(`logging in displays the user's username`, async () => {\n  render(<Login />);\n  const { username, password } = buildLoginForm();\n\n  userEvent.type(screen.getByLabelText(/username/i), username);\n  userEvent.type(screen.getByLabelText(/password/i), password);\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n\n  await waitForElementToBeRemoved(() => screen.getByLabelText(/loading/i));\n\n  expect(screen.getByText(username)).toBeInTheDocument();\n});\n")),Object(r.b)("h3",{id:"testing-the-unhappy-path"},"Testing the unhappy path"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// mocking HTTP requests\n// ğŸ’¯ test the unhappy path\n// http://localhost:3000/login-submission\n\nimport * as React from 'react';\nimport {\n  render,\n  screen,\n  waitForElementToBeRemoved,\n} from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { build, fake } from '@jackfranklin/test-data-bot';\nimport { setupServer } from 'msw/node';\nimport { handlers } from 'test/server-handlers';\nimport Login from '../../components/login-submission';\n\nconst buildLoginForm = build({\n  fields: {\n    username: fake(f => f.internet.userName()),\n    password: fake(f => f.internet.password()),\n  },\n});\n\nconst server = setupServer(...handlers);\n\nbeforeAll(() => server.listen());\nafterAll(() => server.close());\n\ntest(`logging in displays the user's username`, async () => {\n  render(<Login />);\n  const { username, password } = buildLoginForm();\n\n  userEvent.type(screen.getByLabelText(/username/i), username);\n  userEvent.type(screen.getByLabelText(/password/i), password);\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n\n  await waitForElementToBeRemoved(() => screen.getByLabelText(/loading/i));\n\n  expect(screen.getByText(username)).toBeInTheDocument();\n});\n\ntest('omitting the password results in an error', async () => {\n  render(<Login />);\n  const { username } = buildLoginForm();\n\n  userEvent.type(screen.getByLabelText(/username/i), username);\n  // don't type in the password\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n\n  await waitForElementToBeRemoved(() => screen.getByLabelText(/loading/i));\n\n  expect(screen.getByRole('alert')).toHaveTextContent('password required');\n});\n")),Object(r.b)("h2",{id:"use-inline-snapshots"},"Use inline snapshots"),Object(r.b)("p",null,'It is not great to hardcode things such as "error messages" in case the error message ever changes.'),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// mocking HTTP requests\n// ğŸ’¯ use inline snapshots for error messages\n// http://localhost:3000/login-submission\n\nimport * as React from 'react';\nimport {\n  render,\n  screen,\n  waitForElementToBeRemoved,\n} from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { build, fake } from '@jackfranklin/test-data-bot';\nimport { setupServer } from 'msw/node';\nimport { handlers } from 'test/server-handlers';\nimport Login from '../../components/login-submission';\n\nconst buildLoginForm = build({\n  fields: {\n    username: fake(f => f.internet.userName()),\n    password: fake(f => f.internet.password()),\n  },\n});\n\nconst server = setupServer(...handlers);\n\nbeforeAll(() => server.listen());\nafterAll(() => server.close());\n\ntest(`logging in displays the user's username`, async () => {\n  render(<Login />);\n  const { username, password } = buildLoginForm();\n\n  userEvent.type(screen.getByLabelText(/username/i), username);\n  userEvent.type(screen.getByLabelText(/password/i), password);\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n\n  await waitForElementToBeRemoved(() => screen.getByLabelText(/loading/i));\n\n  expect(screen.getByText(username)).toBeInTheDocument();\n});\n\ntest('omitting the password results in an error', async () => {\n  render(<Login />);\n  const { username } = buildLoginForm();\n\n  userEvent.type(screen.getByLabelText(/username/i), username);\n  // don't type in the password\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n\n  await waitForElementToBeRemoved(() => screen.getByLabelText(/loading/i));\n\n  expect(screen.getByRole('alert').textContent).toMatchInlineSnapshot(\n    `\"password required\"`,\n  );\n});\n")),Object(r.b)("h3",{id:"using-one-off-server-handlers"},"Using one-off server handlers"),Object(r.b)("p",null,"This is an ability to override the current handlers that have been implemented."),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// mocking HTTP requests\n// ğŸ’¯ use one-off server handlers\n// http://localhost:3000/login-submission\n\nimport * as React from 'react';\nimport {\n  render,\n  screen,\n  waitForElementToBeRemoved,\n} from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { build, fake } from '@jackfranklin/test-data-bot';\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\nimport { handlers } from 'test/server-handlers';\nimport Login from '../../components/login-submission';\n\nconst buildLoginForm = build({\n  fields: {\n    username: fake(f => f.internet.userName()),\n    password: fake(f => f.internet.password()),\n  },\n});\n\nconst server = setupServer(...handlers);\n\nbeforeAll(() => server.listen());\nafterAll(() => server.close());\nafterEach(() => server.resetHandlers());\n\ntest(`logging in displays the user's username`, async () => {\n  render(<Login />);\n  const { username, password } = buildLoginForm();\n\n  userEvent.type(screen.getByLabelText(/username/i), username);\n  userEvent.type(screen.getByLabelText(/password/i), password);\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n\n  await waitForElementToBeRemoved(() => screen.getByLabelText(/loading/i));\n\n  expect(screen.getByText(username)).toBeInTheDocument();\n});\n\ntest('omitting the password results in an error', async () => {\n  render(<Login />);\n  const { username } = buildLoginForm();\n\n  userEvent.type(screen.getByLabelText(/username/i), username);\n  // don't type in the password\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n\n  await waitForElementToBeRemoved(() => screen.getByLabelText(/loading/i));\n\n  expect(screen.getByRole('alert').textContent).toMatchInlineSnapshot(\n    `\"password required\"`,\n  );\n});\n\ntest('unknown server error displays the error message', async () => {\n  const testErrorMessage = 'Oh no, something bad happened';\n  server.use(\n    rest.post(\n      'https://auth-provider.example.com/api/login',\n      async (req, res, ctx) => {\n        return res(ctx.status(500), ctx.json({ message: testErrorMessage }));\n      },\n    ),\n  );\n  render(<Login />);\n  userEvent.click(screen.getByRole('button', { name: /submit/i }));\n\n  await waitForElementToBeRemoved(() => screen.getByLabelText(/loading/i));\n\n  expect(screen.getByRole('alert')).toHaveTextContent(testErrorMessage);\n});\n")),Object(r.b)("h2",{id:"mocking-browser-apis-and-modules"},"Mocking Browser APIs and Modules"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"Mocking HTTP requests is one thing, but sometimes you have entire Browser APIs\nor modules that you need to mock. Every time you create a fake version of what\nyour code actually uses, you're \"poking a hole in reality\" and you lose some\nconfidence as a result (which is why E2E tests are critical). Remember, we're\ndoing it and recognizing that we're trading confidence for some practicality or\nconvenience in our testing. (Read more about this in my blog post:\n",Object(r.b)("a",s({parentName:"p"},{href:"https://kentcdodds.com/blog/the-merits-of-mocking"}),"The Merits of Mocking"),').\nTo learn more about what "mocking" even is, take a look at my blog post\n',Object(r.b)("a",s({parentName:"p"},{href:"https://kentcdodds.com/blog/but-really-what-is-a-javascript-mock"}),"But really, what is a JavaScript mock?"))),Object(r.b)("p",null,"An example is when Kent needed to mock the browser ",Object(r.b)("inlineCode",{parentName:"p"},"window.resizeTo")," and polyfill ",Object(r.b)("inlineCode",{parentName:"p"},"window.matchMedia"),":"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"import matchMediaPolyfill from 'mq-polyfill';\n\nbeforeAll(() => {\n  matchMediaPolyfill(window);\n  window.resizeTo = function resizeTo(width, height) {\n    Object.assign(this, {\n      innerWidth: width,\n      innerHeight: height,\n      outerWidth: width,\n      outerHeight: height,\n    }).dispatchEvent(new this.Event('resize'));\n  };\n});\n")),Object(r.b)("p",null,"This allows to capability of continuing to test in Jest while not running in a browser."),Object(r.b)("p",null,"Sometimes, a module is doing something you don't want to actually do in tests.\nJest makes it relatively simple to mock a module:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-javascript"}),"// math.js\nexport const add = (a, b) => a + b;\nexport const subtract = (a, b) => a - b;\n\n// __tests__/some-test.js\nimport { add, subtract } from '../math';\n\njest.mock('../math');\n\n// now all the function exports from the \"math.js\" module are jest mock functions\n// so we can call .mockImplementation(...) on them\n// and make assertions like .toHaveBeenCalledTimes(...)\n")),Object(r.b)("p",null,"Additionally, if you'd like to mock only ",Object(r.b)("em",{parentName:"p"},"parts"),' of a module, you can provide\nyour own "mock module getter" function:'),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-javascript"}),"jest.mock('../math', () => {\n  const actualMath = jest.requireActual('../math');\n  return {\n    ...actualMath,\n    subtract: jest.fn(),\n  };\n});\n\n// now the `add` export is the normal function,\n// but the `subtract` export is a mock function.\n")),Object(r.b)("p",null,"Mocking in action:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// mocking Browser APIs and modules\n// http://localhost:3000/location\n\nimport * as React from 'react';\nimport { render, screen, act } from '@testing-library/react';\nimport Location from '../../examples/location';\n\nbeforeAll(() => {\n  window.navigator.geolocation = {\n    getCurrentPosition: jest.fn(),\n  };\n});\n\nfunction deferred() {\n  let resolve, reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve, reject };\n}\n\ntest('displays the users current location', async () => {\n  const fakePosition = {\n    coords: {\n      latitude: 35,\n      longitude: 139,\n    },\n  };\n  const { promise, resolve } = deferred();\n  window.navigator.geolocation.getCurrentPosition.mockImplementation(\n    callback => {\n      promise.then(() => callback(fakePosition));\n    },\n  );\n\n  render(<Location />);\n\n  expect(screen.getByLabelText(/loading/i)).toBeInTheDocument();\n\n  await act(async () => {\n    resolve();\n    await promise;\n  });\n\n  expect(screen.queryByLabelText(/loading/i)).not.toBeInTheDocument();\n\n  expect(screen.getByText(/latitude/i)).toHaveTextContent(\n    `Latitude: ${fakePosition.coords.latitude}`,\n  );\n  expect(screen.getByText(/longitude/i)).toHaveTextContent(\n    `Longitude: ${fakePosition.coords.longitude}`,\n  );\n});\n")),Object(r.b)("p",null,"The act function is placed around the resolve (you'll see the error show up in the console) and it happens because the callback is updating the state in a 3rd-party component being used."),Object(r.b)("p",null,"We need to ensure all the side-effects are flushed before we continuing with the tests (effects that may be inperceivable to us)."),Object(r.b)("p",null,"It will now ensure that UI is stable. It is one of the few places where you need to use the ",Object(r.b)("inlineCode",{parentName:"p"},"act")," API."),Object(r.b)("h3",{id:"act-function"},"Act Function"),Object(r.b)("p",null,"In the above."),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// mocking Browser APIs and modules\n// ğŸ’¯ test the unhappy path\n// http://localhost:3000/location\n\nimport React from 'react';\nimport { render, screen, act } from '@testing-library/react';\nimport Location from '../../examples/location';\n\nbeforeAll(() => {\n  window.navigator.geolocation = {\n    getCurrentPosition: jest.fn(),\n  };\n});\n\nfunction deferred() {\n  let resolve, reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve, reject };\n}\n\ntest('displays the users current location', async () => {\n  const fakePosition = {\n    coords: {\n      latitude: 35,\n      longitude: 139,\n    },\n  };\n  const { promise, resolve } = deferred();\n  window.navigator.geolocation.getCurrentPosition.mockImplementation(\n    callback => {\n      promise.then(() => callback(fakePosition));\n    },\n  );\n\n  render(<Location />);\n\n  expect(screen.getByLabelText(/loading/i)).toBeInTheDocument();\n\n  await act(async () => {\n    resolve();\n    await promise;\n  });\n\n  expect(screen.queryByLabelText(/loading/i)).not.toBeInTheDocument();\n\n  expect(screen.getByText(/latitude/i)).toHaveTextContent(\n    `Latitude: ${fakePosition.coords.latitude}`,\n  );\n  expect(screen.getByText(/longitude/i)).toHaveTextContent(\n    `Longitude: ${fakePosition.coords.longitude}`,\n  );\n});\n\ntest('displays error message when geolocation is not supported', async () => {\n  const fakeError = new Error(\n    'Geolocation is not supported or permission denied',\n  );\n  const { promise, reject } = deferred();\n\n  window.navigator.geolocation.getCurrentPosition.mockImplementation(\n    (successCallback, errorCallback) => {\n      promise.catch(() => errorCallback(fakeError));\n    },\n  );\n\n  render(<Location />);\n\n  expect(screen.getByLabelText(/loading/i)).toBeInTheDocument();\n\n  await act(async () => {\n    reject();\n  });\n\n  expect(screen.queryByLabelText(/loading/i)).not.toBeInTheDocument();\n\n  expect(screen.getByRole('alert')).toHaveTextContent(fakeError.message);\n});\n")),Object(r.b)("h3",{id:"mock-the-module"},"Mock the module"),Object(r.b)("p",null,"This is an alternative way to solve the problem through mocking."),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// mocking Browser APIs and modules\n// ğŸ’¯ mock the module\n// http://localhost:3000/location\n\nimport * as React from 'react';\nimport { render, screen, act } from '@testing-library/react';\nimport { useCurrentPosition } from 'react-use-geolocation';\nimport Location from '../../examples/location';\n\njest.mock('react-use-geolocation');\n\ntest('displays the users current location', async () => {\n  const fakePosition = {\n    coords: {\n      latitude: 35,\n      longitude: 139,\n    },\n  };\n\n  let setReturnValue;\n  function useMockCurrentPosition() {\n    const state = React.useState([]);\n    setReturnValue = state[1];\n    return state[0];\n  }\n  useCurrentPosition.mockImplementation(useMockCurrentPosition);\n\n  render(<Location />);\n  expect(screen.getByLabelText(/loading/i)).toBeInTheDocument();\n\n  act(() => {\n    setReturnValue([fakePosition]);\n  });\n\n  expect(screen.queryByLabelText(/loading/i)).not.toBeInTheDocument();\n  expect(screen.getByText(/latitude/i)).toHaveTextContent(\n    `Latitude: ${fakePosition.coords.latitude}`,\n  );\n  expect(screen.getByText(/longitude/i)).toHaveTextContent(\n    `Longitude: ${fakePosition.coords.longitude}`,\n  );\n});\n")),Object(r.b)("h2",{id:"context-and-custom-render-method"},"Context and Custom Render Method"),Object(r.b)("p",null,"How to test components that use context."),Object(r.b)("p",null,"From the lesson:"),Object(r.b)("p",null,"A common question when testing React components is what to do with React\ncomponents that use context values. If you take a step back and consider the\nguiding testing philosophy of writing tests that resemble the way our software\nis used, then you'll know that you want to render your component with the\nprovider:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-javascript"}),"render(\n  <ContextProvider>\n    <ComponentToTest />\n  </ContextProvider>,\n);\n")),Object(r.b)("p",null,"The one problem with this is if you want to re-render the ",Object(r.b)("inlineCode",{parentName:"p"},"<ComponentToTest />"),"\n(for example, to give it new props and test how it responds to updated props),\nthen you have to include the context providers:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-javascript"}),"const { rerender } = render(\n  <ContextProvider>\n    <ComponentToTest />\n  </ContextProvider>,\n);\n\nrerender(\n  <ContextProvider>\n    <ComponentToTest newProp={true} />\n  </ContextProvider>,\n);\n")),Object(r.b)("p",null,"This is kind of annoying, so instead, you can provide a ",Object(r.b)("inlineCode",{parentName:"p"},"wrapper")," option and\nthat will ensure that rerenders are wrapped as well:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-javascript"}),"function Wrapper({ children }) {\n  return <ContextProvider>{children}</ContextProvider>;\n}\n\nconst { rerender } = render(<ComponentToTest />, { wrapper: Wrapper });\n\nrerender(<ComponentToTest newProp={true} />);\n")),Object(r.b)("p",null,"ğŸ“œ ",Object(r.b)("a",s({parentName:"p"},{href:"https://testing-library.com/docs/react-testing-library/api#wrapper"}),"https://testing-library.com/docs/react-testing-library/api#wrapper")),Object(r.b)("p",null,"This ",Object(r.b)("inlineCode",{parentName:"p"},"Wrapper")," could include providers for all your context providers in your\napp: Router, Theme, Authentication, etc."),Object(r.b)("p",null,"To take it further, you could create your own custom render method that does\nthis automatically:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-javascript"}),'import { render as rtlRender } from \'@testing-library/react\';\n// "rtl" is short for "react testing library" not "right-to-left" ğŸ˜…\n\nfunction render(ui, options) {\n  return rtlRender(ui, { wrapper: Wrapper, ...options });\n}\n\n// then in your tests, you don\'t need to worry about context at all:\nconst { rerender } = render(<ComponentToTest />);\n\nrerender(<ComponentToTest newProp={true} />);\n')),Object(r.b)("p",null,"From there, you can put that custom render function in your own module and use\nyour custom render method instead of the built-in one from React Testing\nLibrary. Learn more about this from the docs:"),Object(r.b)("p",null,"ğŸ“œ ",Object(r.b)("a",s({parentName:"p"},{href:"https://testing-library.com/docs/react-testing-library/setup"}),"https://testing-library.com/docs/react-testing-library/setup")),Object(r.b)("p",null,"A basic example of this in practise (not the custom setup):"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// testing with context and a custom render method\n// http://localhost:3000/easy-button\n\nimport * as React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport { ThemeProvider } from '../../components/theme';\nimport EasyButton from '../../components/easy-button';\n\ntest('renders with the light styles for the light theme', () => {\n  const Wrapper = ({ children }) => (\n    <ThemeProvider initialTheme=\"light\">{children}</ThemeProvider>\n  );\n  render(<EasyButton>Easy</EasyButton>, { wrapper: Wrapper });\n  const button = screen.getByRole('button', { name: /easy/i });\n  expect(button).toHaveStyle(`\n    background-color: white;\n    color: black;\n  `);\n});\n")),Object(r.b)("h3",{id:"render-method"},"Render Method"),Object(r.b)("p",null,"This will be a special render function to encaspsulate the duplication."),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// testing with context and a custom render method\n// ğŸ’¯ create a custom render method\n// http://localhost:3000/easy-button\n\nimport * as React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport { ThemeProvider } from '../../components/theme';\nimport EasyButton from '../../components/easy-button';\n\nfunction renderWithProviders(ui, { theme = 'light', ...options } = {}) {\n  const Wrapper = ({ children }) => (\n    <ThemeProvider value={[theme, () => {}]}>{children}</ThemeProvider>\n  );\n  return render(ui, { wrapper: Wrapper, ...options });\n}\n\ntest('renders with the light styles for the light theme', () => {\n  renderWithProviders(<EasyButton>Easy</EasyButton>);\n  const button = screen.getByRole('button', { name: /easy/i });\n  expect(button).toHaveStyle(`\n    background-color: white;\n    color: black;\n  `);\n});\n\ntest('renders with the dark styles for the dark theme', () => {\n  renderWithProviders(<EasyButton>Easy</EasyButton>, {\n    theme: 'dark',\n  });\n  const button = screen.getByRole('button', { name: /easy/i });\n  expect(button).toHaveStyle(`\n    background-color: black;\n    color: white;\n  `);\n});\n")),Object(r.b)("h3",{id:"app-test-utils"},"App Test Utils"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},Object(r.b)("em",{parentName:"p"},"\"Now, we want to swap the @testing-library/react module with our app-test-utils. What I recommend for every application that's using React Testing Library, your test should not import @testing-library/react.")," > ",Object(r.b)("em",{parentName:"p"},'"Instead, you should make your own module that re-exports everything from @testing-library/react and has a render() with providers type of function. We\'ve already got this if we go to our test directory and then test-utils. Then right in here, we are doing something that looks a little familiar."'))),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// testing with context and a custom render method\n// ğŸ’¯ swap @testing-library/react with app test utils\n// http://localhost:3000/easy-button\n\nimport * as React from 'react';\nimport { render, screen } from 'test/test-utils';\nimport EasyButton from '../../components/easy-button';\n\ntest('renders with the light styles for the light theme', () => {\n  render(<EasyButton>Easy</EasyButton>, { theme: 'light' });\n  const button = screen.getByRole('button', { name: /easy/i });\n  expect(button).toHaveStyle(`\n    background-color: white;\n    color: black;\n  `);\n});\n\ntest('renders with the dark styles for the dark theme', () => {\n  render(<EasyButton>Easy</EasyButton>, { theme: 'dark' });\n  const button = screen.getByRole('button', { name: /easy/i });\n  expect(button).toHaveStyle(`\n    background-color: black;\n    color: white;\n  `);\n});\n")),Object(r.b)("p",null,"You can setup the relative path to be absolute if you setup you ",Object(r.b)("inlineCode",{parentName:"p"},"jest.config.js")," file correctly to handle it under ",Object(r.b)("inlineCode",{parentName:"p"},"moduleDirectories"),"!"),Object(r.b)("p",null,"Docs can be found on the ",Object(r.b)("a",s({parentName:"p"},{href:"https://jestjs.io/docs/en/configuration"}),"Jest website")),Object(r.b)("h2",{id:"testing-custom-hooks"},"Testing Custom Hooks"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},Object(r.b)("em",{parentName:"p"},'"Testing custom hooks is probably something you shouldn\'t do. You should just test those components."'))),Object(r.b)("p",null,"Kent considers it to be more of an implementation detail."),Object(r.b)("p",null,"Going with the first option of testing the component using it, we have the following code:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// testing custom hooks\n// http://localhost:3000/counter-hook\n\nimport * as React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport useCounter from '../../components/use-counter';\n\nfunction UseCounterHookExample() {\n  const { count, increment, decrement } = useCounter();\n  return (\n    <div>\n      <div>Current count: {count}</div>\n      <button onClick={decrement}>Decrement</button>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n\ntest('exposes the count and increment/decrement functions', () => {\n  render(<UseCounterHookExample />);\n  const increment = screen.getByRole('button', { name: /increment/i });\n  const decrement = screen.getByRole('button', { name: /decrement/i });\n  const message = screen.getByText(/current count/i);\n\n  expect(message).toHaveTextContent('Current count: 0');\n  userEvent.click(increment);\n  expect(message).toHaveTextContent('Current count: 1');\n  userEvent.click(decrement);\n  expect(message).toHaveTextContent('Current count: 0');\n});\n")),Object(r.b)("p",null,"Kent mentions that this is the type of test that he would write."),Object(r.b)("h3",{id:"using-a-fake-component"},"Using a fake component"),Object(r.b)("p",null,"This removes the use an example component altogether. This is useful for complicated custom hooks."),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// testing custom hooks\n// ğŸ’¯ fake component\n// http://localhost:3000/counter-hook\n\nimport * as React from 'react';\nimport { render, act } from '@testing-library/react';\nimport useCounter from '../../components/use-counter';\n\ntest('exposes the count and increment/decrement functions', () => {\n  let result;\n  function TestComponent() {\n    result = useCounter();\n    return null;\n  }\n  render(<TestComponent />);\n  expect(result.count).toBe(0);\n  act(() => result.increment());\n  expect(result.count).toBe(1);\n  act(() => result.decrement());\n  expect(result.count).toBe(0);\n});\n")),Object(r.b)("h3",{id:"using-a-setup-function-and-implementing-more-tests"},"Using a setup function and implementing more tests"),Object(r.b)("p",null,"This is for abstraction of reused faking."),Object(r.b)("p",null,"We need to also ues ",Object(r.b)("inlineCode",{parentName:"p"},"result.current")," due to referential binding. Without it, each re-render for ",Object(r.b)("inlineCode",{parentName:"p"},"TestComponent")," would reset the ",Object(r.b)("inlineCode",{parentName:"p"},"result")," variable in setup."),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// testing custom hooks\n// ğŸ’¯ setup function\n// http://localhost:3000/counter-hook\n\nimport * as React from 'react';\nimport { render, act } from '@testing-library/react';\nimport useCounter from '../../components/use-counter';\n\nfunction setup({ initialProps } = {}) {\n  const result = {};\n  function TestComponent(props) {\n    result.current = useCounter(props);\n    return null;\n  }\n  render(<TestComponent {...initialProps} />);\n  return result;\n}\n\ntest('exposes the count and increment/decrement functions', () => {\n  const result = setup();\n  expect(result.current.count).toBe(0);\n  act(() => result.current.increment());\n  expect(result.current.count).toBe(1);\n  act(() => result.current.decrement());\n  expect(result.current.count).toBe(0);\n});\n\ntest('allows customization of the initial count', () => {\n  const result = setup({ initialProps: { initialCount: 3 } });\n  expect(result.current.count).toBe(3);\n});\n\ntest('allows customization of the step', () => {\n  const result = setup({ initialProps: { step: 2 } });\n  expect(result.current.count).toBe(0);\n  act(() => result.current.increment());\n  expect(result.current.count).toBe(2);\n  act(() => result.current.decrement());\n  expect(result.current.count).toBe(0);\n});\n")),Object(r.b)("h3",{id:"using-react-hooks-testing-library"},"Using React-Hooks Testing Library"),Object(r.b)("p",null,"The final option is to avoid all the complexity and just use the React-Hooks testing library:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"// testing custom hooks\n// ğŸ’¯ using react-hooks testing library\n// http://localhost:3000/counter-hook\n\nimport { renderHook, act } from '@testing-library/react-hooks';\nimport useCounter from '../../components/use-counter';\n\ntest('exposes the count and increment/decrement functions', () => {\n  const { result } = renderHook(useCounter);\n  expect(result.current.count).toBe(0);\n  act(() => result.current.increment());\n  expect(result.current.count).toBe(1);\n  act(() => result.current.decrement());\n  expect(result.current.count).toBe(0);\n});\n\ntest('allows customization of the initial count', () => {\n  const { result } = renderHook(useCounter, {\n    initialProps: { initialCount: 3 },\n  });\n  expect(result.current.count).toBe(3);\n});\n\ntest('allows customization of the step', () => {\n  const { result } = renderHook(useCounter, { initialProps: { step: 2 } });\n  expect(result.current.count).toBe(0);\n  act(() => result.current.increment());\n  expect(result.current.count).toBe(2);\n  act(() => result.current.decrement());\n  expect(result.current.count).toBe(0);\n});\n\ntest('the step can be changed', () => {\n  const { result, rerender } = renderHook(useCounter, {\n    initialProps: { step: 3 },\n  });\n  expect(result.current.count).toBe(0);\n  act(() => result.current.increment());\n  expect(result.current.count).toBe(3);\n  rerender({ step: 2 });\n  act(() => result.current.decrement());\n  expect(result.current.count).toBe(1);\n});\n")))}l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"manual/Epic-React/Testing-React-Apps.md"}}),l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---manual-epic-react-testing-react-apps-md-a1129070f3db0822d402.js.map