(window.webpackJsonp=window.webpackJsonp||[]).push([[434],{"Ext/":function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return i})),t.d(n,"default",(function(){return c}));t("1c7q"),t("abGl"),t("gZHo"),t("Fdmb"),t("Ir+3"),t("2mQt"),t("mXGw");var a=t("/FXl"),r=t("TjRS");t("aD51");function o(){return(o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var i={};void 0!==i&&i&&i===Object(i)&&Object.isExtensible(i)&&!i.hasOwnProperty("__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"manual/Programming-Languages/Creating-Your-Own-Language.md"}});var s={_frontmatter:i},l=r.a;function c(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,["components"]);return Object(a.b)(l,o({},s,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"creating-your-own-language"},"Creating Your Own Language"),Object(a.b)("h2",{id:"resources"},"Resources"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",o({parentName:"li"},{href:"https://github.com/stevekinney/dropbear/"}),"Dropbear GitHub language")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",o({parentName:"li"},{href:"http://static.frontendmasters.com/resources/2019-05-31-build-your-own-programming-language/programming-language.pdf"}),"Slides"))),Object(a.b)("h2",{id:"why-your-own-language"},"Why your own language?"),Object(a.b)("p",null,"There are elements that are super practical for production code."),Object(a.b)("h3",{id:"use-cases"},"Use Cases"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Domain-Specific Languages: Terraform, Gemfiles"),Object(a.b)("li",{parentName:"ol"},"Templating languages: Handlebars, Pug")),Object(a.b)("h3",{id:"usecases-at-sendgrid"},"Usecases at SendGrid"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Drag + Drop editor takes HTML, parses it into an abstract syntax tree (AST) and manipulates it before serializing it back into HTML."),Object(a.b)("li",{parentName:"ul"},"Using it for own bespoke templating language for dynamic email templates."),Object(a.b)("li",{parentName:"ul"},"Sync position in side-by-side editor by breaking HTML into an AST and rewriting the elements with information about their position in the text editor.")),Object(a.b)("h2",{id:"what-is-a-compiler"},"What is a compiler?"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Something that turns a higher-level language into a lower-level langauge.")),Object(a.b)("p",null,"In this particular example, we will follow the course that builds the language ",Object(a.b)("inlineCode",{parentName:"p"},"Dropbear"),"."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Lisp-like language"),Object(a.b)("li",{parentName:"ul"},"Leverage existing JavaScript run-time")),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-s"}),"(add 1 2 (subtract 6 3))\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Source code is meant to be human-readable.")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"The beauty of Scheme is that the full language only needs\n5 keywords and 8 syntactic forms. In comparison, Python\nhas 33 keywords and 110 syntactic forms, and Java has 50\nkeywords and 133 syntactic forms. — Peter Norvig.")),Object(a.b)("h3",{id:"inspiration-resources"},"Inspiration Resources"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"https://norvig.com/lispy.html"}),"https://norvig.com/lispy.html")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"https://eloquentjavascript.net/12_language.html"}),"https://eloquentjavascript.net/12_language.html")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"https://github.com/jamiebuilds/the-super-tiny-compiler"}),"https://github.com/jamiebuilds/the-super-tiny-compiler"))),Object(a.b)("h2",{id:"stages-of-a-compiler"},"Stages of a Compiler"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Parsing: Take source code and turn it into representation of that code."),Object(a.b)("li",{parentName:"ol"},"Transformation: Take source code and transforms it to do whatever the compiler wants it to do."),Object(a.b)("li",{parentName:"ol"},"Generation: Take the transformed representation and turns it into a new string of code.")),Object(a.b)("h2",{id:"parsing"},"Parsing"),Object(a.b)("p",null,"Parsing consists of:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"Lexical analysis")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"Syntactic analysis"))),Object(a.b)("p",null,"Note: Lexing = Lexical analysis."),Object(a.b)("p",null,"Basically: take big string of code and turn it into ",Object(a.b)("inlineCode",{parentName:"p"},"tokens")," where a ",Object(a.b)("inlineCode",{parentName:"p"},"token")," is a small unit of the language."),Object(a.b)("p",null,"How might a lexer work?"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Accept input string of code"),Object(a.b)("li",{parentName:"ul"},"Create var for tracking position (like cursor)"),Object(a.b)("li",{parentName:"ul"},"Make an array of tokens"),Object(a.b)("li",{parentName:"ul"},"Write a while loop that iterates through the source code input"),Object(a.b)("li",{parentName:"ul"},"Check each token, see if matches type"),Object(a.b)("li",{parentName:"ul"},"Add it to the array of token")),Object(a.b)("h3",{id:"using-helpers"},"Using helpers"),Object(a.b)("p",null,"This is an example of helpers, but it is worth writing them early and often."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"const isWhitespace = character => /\\s/.test(character);\nconst isNumber = character => /[0-9]/.test(character);\nconst isOperator = character => /[\\+\\-\\*\\/]/.test(character);\n")),Object(a.b)("h3",{id:"turning-strings-to-tokens"},"Turning strings to tokens"),Object(a.b)("p",null,"Note that based on our syntax, we may need to collect multiple characters into a single token ie ",Object(a.b)("inlineCode",{parentName:"p"},"22 + 23")," (which tokenizes as ",Object(a.b)("inlineCode",{parentName:"p"},"['2','2','+','2','3']"),")"),Object(a.b)("p",null,"We write a ",Object(a.b)("inlineCode",{parentName:"p"},"tokenize")," function that takes these helpers for us to tokenize the code that we are parsing."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"const {\n  isLetter,\n  isWhitespace,\n  isNumber,\n  isParenthesis,\n  isQuote,\n} = require('./identify');\n\nconst tokenize = input => {\n  const tokens = [];\n  let cursor = 0;\n\n  while (cursor < input.length) {\n    const character = input[cursor];\n\n    if (isParenthesis(character)) {\n      tokens.push({\n        type: 'Parenthesis',\n        value: character,\n      });\n      cursor++;\n      continue;\n    }\n\n    if (isWhitespace(character)) {\n      cursor++;\n      continue;\n    }\n\n    if (isNumber(character)) {\n      let number = character;\n\n      while (isNumber(input[++cursor])) {\n        number += input[cursor];\n      }\n\n      tokens.push({\n        type: 'Number',\n        value: parseInt(number, 10),\n      });\n\n      continue;\n    }\n\n    if (isLetter(character)) {\n      let symbol = character;\n\n      while (isLetter(input[++cursor])) {\n        symbol += input[cursor];\n      }\n\n      tokens.push({\n        type: 'Name',\n        value: symbol,\n      });\n\n      continue;\n    }\n\n    if (isQuote(character)) {\n      let string = '';\n\n      while (!isQuote(input[++cursor])) {\n        string += input[cursor];\n      }\n\n      tokens.push({\n        type: 'String',\n        value: string,\n      });\n\n      cursor++;\n      continue;\n    }\n\n    throw new Error(`${character} is not valid`);\n  }\n\n  return tokens;\n};\n\nmodule.exports = { tokenize };\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"String traversal and string manipulation in JavaScript is really fast.")),Object(a.b)("h2",{id:"building-an-ast"},"Building an AST"),Object(a.b)("p",null,"How could we build an AST?"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Iterate through the array of tokens."),Object(a.b)("li",{parentName:"ol"},"For each number, string, etc. add that token to same level of the tree."),Object(a.b)("li",{parentName:"ol"},"For each ",Object(a.b)("inlineCode",{parentName:"li"},"CallExpression")," (e.g. function) collect the parameters and then recurse down into the function body.")),Object(a.b)("p",null,"Babel is kind of the de facto standard for the AST, so it is worth being able to parse our tokens into a format that Babel can handle."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// identify.js\nconst LETTER = /[a-zA-Z]/;\nconst WHITESPACE = /\\s+/;\nconst NUMBER = /^[0-9]+$/;\nconst OPERATORS = ['+', '-', '*', '/', '%'];\n\nconst isLetter = character => LETTER.test(character);\n\nconst isWhitespace = character => WHITESPACE.test(character);\n\nconst isNumber = character => NUMBER.test(character);\n\nconst isOpeningParenthesis = character => character === '(';\n\nconst isClosingParenthesis = character => character === ')';\n\nconst isParenthesis = character =>\n  isOpeningParenthesis(character) || isClosingParenthesis(character);\n\nconst isQuote = character => character === '\"';\n\nconst isOperator = character => OPERATORS.includes(character);\n\nmodule.exports = {\n  isLetter,\n  isWhitespace,\n  isNumber,\n  isOpeningParenthesis,\n  isClosingParenthesis,\n  isParenthesis,\n  isQuote,\n  isOperator,\n};\n\n// utilities.js\nconst tap = require('lodash/tap');\n\nconst pipe = (...funcs) => value =>\n  funcs.reduce((value, func) => func(value), value);\n\nconst log = value => tap(value, console.log);\n\nconst peek = array => array[0];\nconst pop = array => array.shift();\n\nmodule.exports = {\n  pipe,\n  log,\n  peek,\n  pop,\n  tap,\n};\n\n// parse.js\nconst { isOpeningParenthesis, isClosingParenthesis } = require('./identify');\nconst { specialForms } = require('./special-forms');\nconst { peek, pop } = require('./utilities');\n\nconst parenthesize = tokens => {\n  const token = pop(tokens);\n\n  if (isOpeningParenthesis(token.value)) {\n    const expression = [];\n\n    while (!isClosingParenthesis(peek(tokens).value)) {\n      expression.push(parenthesize(tokens));\n    }\n\n    pop(tokens);\n    return expression;\n  }\n\n  return token;\n};\n\nconst parse = tokens => {\n  if (Array.isArray(tokens)) {\n    const [first, ...rest] = tokens;\n    return {\n      type: 'CallExpression',\n      name: first.value,\n      arguments: rest.map(parse),\n    };\n  }\n\n  const token = tokens;\n\n  if (token.type === 'Number') {\n    return {\n      type: 'NumericLiteral',\n      value: token.value,\n    };\n  }\n\n  if (token.type === 'String') {\n    return {\n      type: 'StringLiteral',\n      value: token.value,\n    };\n  }\n\n  if (token.type === 'Name') {\n    return {\n      type: 'Identifier',\n      name: token.value,\n    };\n  }\n};\n\nmodule.exports = { parse: tokens => parse(parenthesize(tokens)) };\n")),Object(a.b)("h2",{id:"repl"},"REPL"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Read-Evaluation-Print-Loop")),Object(a.b)("p",null,"We are going to build a REPL + CLI tool that you could expand."),Object(a.b)("p",null,"Notes for this REPL:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"We're been using functions like add and subtract, but what do\nthose mean?"),Object(a.b)("li",{parentName:"ol"},"Above and beyond having a syntax, most languages have some\namount of a standard library of built-in functions, objects, and\nmethods."),Object(a.b)("li",{parentName:"ol"},"We’re leveraging JavaScript’s built-in numbers and arrays, but\nwe’re going to need some functions too.")),Object(a.b)("p",null,"Since JavaScript is our compile target, we’ll implement our\nbuilt-in functions as JavaScript functions."),Object(a.b)("p",null,"We will add what we need to our ",Object(a.b)("inlineCode",{parentName:"p"},"standard-library.js")," code:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"const all = fn => (...list) => list.reduce(fn);\n\nconst add = all((a, b) => a + b);\nconst subtract = all((a, b) => a - b);\nconst multiply = all((a, b) => a * b);\nconst divide = all((a, b) => a / b);\nconst modulo = all((a, b) => a % b);\nconst log = console.log;\n\nconst environment = {\n  add,\n  subtract,\n  multiply,\n  divide,\n  modulo,\n  log,\n  pi: Math.PI,\n  max(...args) {\n    return Math.max(...args);\n  },\n};\n\nmodule.exports = { environment };\n")),Object(a.b)("p",null,"Then for the REPL ",Object(a.b)("inlineCode",{parentName:"p"},"evaluate.js"),":"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"const { environment } = require('./standard-library');\nconst last = collection => collection[collection.length - 1];\n\nconst apply = node => {\n  const fn = environment[node.name];\n  const args = node.arguments.map(evaluate);\n  if (typeof fn !== 'function') {\n    throw new TypeError(`${node.name} is not a function`);\n  }\n  return fn(...args);\n};\n\nconst getIdentifier = node => {\n  if (environment[node.name]) return environment[node.name];\n  throw new ReferenceError(`${node.name} is not defined`);\n};\n\nconst define = node => {\n  environment[node.identifier.name] = node.assignment.value;\n};\n\nconst evaluate = node => {\n  if (node.type === 'VariableDeclaration') return define(node);\n  if (node.type === 'CallExpression') return apply(node);\n  if (node.type === 'Identifier') return getIdentifier(node);\n  if (node.value) return node.value;\n};\n\nmodule.exports = { evaluate };\n")),Object(a.b)("h3",{id:"building-the-repl"},"Building the REPL"),Object(a.b)("p",null,"We can create a",Object(a.b)("inlineCode",{parentName:"p"},"repl.js")," file to help run a REPL:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"const { prompt } = require('inquirer');\nconst chalk = require('chalk');\n\nconst { parseAndEvaluate } = require('./parse-and-evaluate');\n\nconst askQuestions = () => {\n  const questions = [\n    { name: 'COMMAND', type: 'input', message: chalk.blue('>') },\n  ];\n\n  return prompt(questions);\n};\n\nconst repl = async () => {\n  try {\n    const answers = await askQuestions();\n    const { COMMAND } = answers;\n\n    if (COMMAND.trim()) {\n      console.log(chalk.yellow(parseAndEvaluate(COMMAND)));\n    }\n  } catch (error) {\n    console.error(error);\n  }\n\n  repl();\n};\n\nif (require.main === module) {\n  console.log(\n    chalk.red(\n      `Welcome to the ${chalk.bgYellow('Dropbear')} Programming Language`,\n    ),\n  );\n  repl();\n}\n\nmodule.exports = repl;\n")),Object(a.b)("h2",{id:"generation"},"Generation"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Parsing, in reverse.")),Object(a.b)("p",null,"For generation, you have a few options:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Write your own low-level CPU-instruction compiler (probably a bad idea)."),Object(a.b)("li",{parentName:"ol"},"Use a compiler framework like LLVM (Rust, Swift, Objective-C)."),Object(a.b)("li",{parentName:"ol"},"Target the JVM."),Object(a.b)("li",{parentName:"ol"},"Transpile to another language.")),Object(a.b)("p",null,"If you can get yourself to a Babel-compliant AST, then you can use another tool off the shelf like Babel generator."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"import generate from '@babel/generator';\n\ngenerate(ast, options, code);\n")),Object(a.b)("p",null,"We need to transform a AST that you currently have to one that Babel can understand."),Object(a.b)("h3",{id:"visitor-pattern"},"Visitor Pattern"),Object(a.b)("p",null,"Basically a depth-first search through the tree. The Visitor Pattern allows us define different types of actions for each node visited as it walks the tree."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"import traverse from '@babel/traverse';\n\ntraverse(ast, {\n  enter(path) {\n    if (path.node.type === 'VariableDeclaration' && path.node.kind === 'var') {\n      path.node.kind = 'let';\n    }\n  },\n});\n")),Object(a.b)("p",null,"The traversal implementation that we put into the app:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"const traverseNode = ({ node, parent, visitor }) => {\n  const methods = visitor[node.type];\n\n  if (methods && methods.enter) {\n    methods.enter({ node, parent });\n  }\n\n  if (node.arguments) {\n    traverseArray({ array: node.arguments, parent: node, visitor });\n  }\n\n  if (methods && methods.exit) {\n    methods.exit({ node, parent });\n  }\n};\n\nconst traverseArray = ({ array, parent, visitor }) => {\n  array.forEach(node => {\n    traverseNode({ node, parent, visitor });\n  });\n};\n\nconst traverse = (node, visitor) => {\n  traverseNode({ node, visitor });\n};\n\nmodule.exports = { traverse };\n\n// during visitor implementation\n// const visitor = {\n//   VariableDeclaration: {\n//     enter({ node, parent }) {},\n//     exit() {}\n//   }\n// }\n")),Object(a.b)("p",null,"This is how we can implement this into JS:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"const generate = require('@babel/generator').default;\nconst { traverse } = require('./traverse');\n\nconst babelVisitor = {\n  CallExpression: {\n    enter({ node }) {\n      node.callee = { type: 'Identifier', name: node.name };\n    },\n  },\n  VariableDeclaration: {\n    enter({ node }) {\n      node.kind = 'let';\n      node.declarations = [\n        {\n          type: 'VariableDeclarator',\n          id: node.identifier,\n          init: node.assignment,\n        },\n      ];\n    },\n  },\n};\n\nconst toJavaScript = ast => {\n  traverse(ast, babelVisitor);\n  return generate(ast).code;\n};\n\nmodule.exports = {\n  toJavaScript,\n};\n")),Object(a.b)("h2",{id:"bonus-terms"},"Bonus Terms"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Homoiconicity: A language that can modify its own underlying data structure."),Object(a.b)("li",{parentName:"ul"},"Self-Hosting: The language is written in the language itself.")))}c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"manual/Programming-Languages/Creating-Your-Own-Language.md"}}),c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---manual-programming-languages-creating-your-own-language-md-b02fd7030a5fe427819d.js.map