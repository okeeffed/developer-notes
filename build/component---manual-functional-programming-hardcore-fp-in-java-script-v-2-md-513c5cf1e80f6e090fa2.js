(window.webpackJsonp=window.webpackJsonp||[]).push([[248],{DSIL:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return s})),t.d(n,"default",(function(){return l}));t("1c7q"),t("abGl"),t("gZHo"),t("Fdmb"),t("Ir+3"),t("2mQt"),t("mXGw");var a=t("/FXl"),o=t("TjRS");t("aD51");function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var s={};void 0!==s&&s&&s===Object(s)&&Object.isExtensible(s)&&!s.hasOwnProperty("__filemeta")&&Object.defineProperty(s,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"manual/Functional-Programming/Hardcore-FP-In-JavaScript-v2.md"}});var i={_frontmatter:s},c=o.a;function l(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,["components"]);return Object(a.b)(c,r({},i,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"hardcore-fp-in-javascript-v2"},"Hardcore FP In JavaScript v2"),Object(a.b)("h2",{id:"resources"},"Resources"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",r({parentName:"li"},{href:"https://frontendmasters.com/courses/hardcore-js-v2/"}),"Functional Programming")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",r({parentName:"li"},{href:"https://codepen.io/drboolean/pen/OJJOQMx?editors=1010"}),"Currying Codepen")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",r({parentName:"li"},{href:"https://codepen.io/drboolean/pen/zYYPmZO"}),"Compose Codepen")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",r({parentName:"li"},{href:"https://codepen.io/drboolean/pen/poodxOm?editors=0010"}),"Functor Codepen")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",r({parentName:"li"},{href:"https://codepen.io/drboolean/pen/xgoeWR?editors=0010"}),"Either Codepen")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",r({parentName:"li"},{href:"https://codepen.io/drboolean/pen/Mparbp?editors=0010"}),"Task Codepen")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",r({parentName:"li"},{href:"https://github.com/FrontendMasters/hardcore-functional-js-v2"}),"GitHub Repo for course"))),Object(a.b)("h2",{id:"pure-functions"},"Pure Functions"),Object(a.b)("p",null,"The definition of a function from set theory is that inputs singularly map to outputs ie one input has an output. A single-valued collection of pairs."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},'Anything that is not one input to an output in the range fails the defintion of a function and things can be done deterministically. This is what makes it "deterministic".')),Object(a.b)("p",null,"Because of this relationship, you could build tables or map to a function graph (think sinusoidal wave) where a input from the domain maps to an output in the range."),Object(a.b)("p",null,'A "total function" (as opposed to a "partial function") means that for every input there is a corresponding output.'),Object(a.b)("p",null,"The other requirement for a pure function is that there are no side effects (no observable effects besides computing a value). Of course there are side effects depending how deep you go into it, but it is a little up to user discression."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"An interesting example was that throwing an error was considering to not be a pure function, although a promise that rejects is. The speaker says you can debate whether this is functional or not.")),Object(a.b)("p",null,"A great example that came up:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"// not a function\nconst signUp = attrs => {\n  let user = saveUser(attrs);\n  welcomeUser(user);\n};\n\n// function\nconst signUp = attrs => () => {\n  let user = saveUser(attrs);\n  welcomeUser(user);\n};\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},'"Kicking the side effect" down the road is a lot of the work arounds that they do to keep functions pure and composable etc.')),Object(a.b)("h2",{id:"why-pure-functions"},"Why Pure Functions?"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Reliable"),Object(a.b)("li",{parentName:"ul"},"Portable"),Object(a.b)("li",{parentName:"ul"},"Reusable"),Object(a.b)("li",{parentName:"ul"},"Testable"),Object(a.b)("li",{parentName:"ul"},"Composable"),Object(a.b)("li",{parentName:"ul"},"Properties/Contract")),Object(a.b)("h2",{id:"properties-of-fp"},"Properties of FP"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"// associative\nadd(add(x, y), z) == add(x, add(y, z));\n\n// commutative\nadd(x, y) == add(y, x);\n\n// identity\nadd(x, 0) == x;\n\n// distributive\nadd(multiply(x, y), multiply(x, z)) == multiply(x, add(y, z));\n")),Object(a.b)("h2",{id:"currying"},"Currying"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"// this\nconst add1 = (x, y) => x + y;\n// could become\nconst add2 = ([x, y]) => x + y;\n\nadd1(x, y) == add2([1, 2]);\n\n// so we could think of this\nconst toPair = f => ([x, y]) => add(x, y);\ntoPair(add)([1, 2]); // equates to the above\n\n// we could also do\nconst fromPair = f => (x, y) => add([x, y]);\n\nconst res = fromPair(toPair(add))(1, 2);\n\n// since we know the args are equivalent...\n// proves isomorphism\nconst flip = f => (y, x) => f(x, y); // communative\nconst flipRes = flip(add)(1, 2);\n\n// finally we get curry!\nconst curry = f => x => y => f(x, y);\nconst curriedAdd = curry(add);\nconst increment = curriedAdd(1);\nconst result = increment(2);\nconsole.log(result);\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"For curried functons, you should always leave the data as the last argument.")),Object(a.b)("p",null,"A nice final example given was currying a replace function:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const replace = curry((regex, replacement, str) =>\n  str.replace(regex, replacement),\n);\n\nconst replaceVowels = replace(/[aeiou]/gi, '');\nconst reesult = getOdds('Hey this works');\nconsole.log(result);\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},'"If you are tying data to all of your functions, then you are incidentally tying all of your functions to that domain." - This hints at point-free.')),Object(a.b)("h2",{id:"partial-application-vs-currying"},"Partial Application vs Currying"),Object(a.b)("p",null,"Currying expects one argument at a time. Partial Applications takes some of the arguments."),Object(a.b)("p",null,"There is a capability with a ",Object(a.b)("inlineCode",{parentName:"p"},"partial")," functional to do this."),Object(a.b)("h2",{id:"compose"},"Compose"),Object(a.b)("p",null,"Composing takes the idea of ",Object(a.b)("inlineCode",{parentName:"p"},"(f, g) => (x) => f(g(x))")," and works because of the properties of functional programming."),Object(a.b)("p",null,"A scratch pad of this in action:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"import { curry, compose, map } from 'ramda';\n\nconst add = (x, y) => x + y;\nconst multiply = (x, y) => x * y;\n\nconst curryAdd = curry(add);\nconst increment = curryAdd(1);\n\nconst curryMultiply = curry(multiply);\nconst double = curryMultiply(2);\n\nconst func = map(\n  compose(\n    double,\n    increment,\n  ),\n);\n\nfunc([1, 2]); // [ 4, 6]\n")),Object(a.b)("p",null,"You can even abstract any composition in any sub composition!"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Left-to-right pipe is the flip or compose.")),Object(a.b)("h2",{id:"functors"},"Functors"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},'"Things aren\'t so dot chainable out of the box."')),Object(a.b)("p",null,'We are going to introduce an identity functor called "Box".'),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"// we need Box to help dot chain this\nconst nextCharForNumberString = str => {\n  const trimmed = str.trim();\n  const number = parseInt(trimmed);\n  const nextNumber = new Number(number + 1);\n  return String.fromCharCode(nextNumber);\n};\n\nconst result = nextCharForNumberString('  64 ');\nconsole.log(result);\n\n// the solution\n\n// here we basically say run a function and keep it\n// in the box\nconst Box = x => ({\n  map: f => Box(f(x)),\n  chain: f => f(x),\n  fold: f => f(x),\n  inspect: `Box(${x})` // just for logging purposes\n});\n\n// For example - Array is an example of keeping things \"in the box\"\nconst example = () =>\n  ['a']\n  .map(x => x.toUpperCase); // ['A'] <- still in the \"box\"\n  .map(x => String.fromCharCode(x)); // ['\\u0000'] <- still in the \"box\"\n\n// the Box in action\nconst exampleWithBox = () =>\n  Box('a')\n  .map(x => x.toUpperCase); // Box('A') <- still in the \"box\"\n  .map(x => String.fromCharCode(x)); // Box('\\u0000') <- still in the \"box\"\n\n// tying this all together\nconst nextCharForNumberStringSolution = str =>\n  Box(str)\n  .map(x => x.trim())\n  .map(x => parseInt(x, 10))\n  .map(x => new Number(x + 1))\n  .fold(x => String.fromCharCode(x)) // could be String.fromCharCode by itself\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},'A Functor because it has a map method. Mathematically it is the operation and the ability to put back into the "box".')),Object(a.b)("p",null,'There is one curve ball that came from the exercises to "box" something:'),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"// Starting code - but it needs to be a Monad! Surprise!\nconst applyDiscount = (price, discount) => {\n  const cents = moneyToFloat(price);\n  const savings = percentToFloat(discount);\n  return cents - cents * savings;\n};\n\n// the final code using the monad\nconst applyDiscount = (price, discount) => {\n  // box inside of a box? wtf?\n  Box(percentToFloat(price)).fold(cents =>\n    Box(moneyToFloat(p)).fold(savings => cents - cents * savings),\n  );\n};\n")),Object(a.b)("p",null,"Box is both a monad and functor and this where we see we need a monad instead of a functor. ",Object(a.b)("inlineCode",{parentName:"p"},"map")," is not required, whereas ",Object(a.b)("inlineCode",{parentName:"p"},"fold")," is! The above is the scenario that monads are used for."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"When you have composition nested inside another composition, you want to flatten it. ",Object(a.b)("inlineCode",{parentName:"p"},"fold")," will do the flattening for us here. There is a method ",Object(a.b)("inlineCode",{parentName:"p"},"chain")," that we can use that will essentially flat map for us so we do not have to have these folds within folds.")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"// the monad with chain\nconst applyDiscount = (price, discount) => {\n  Box(percentToFloat(price))\n    .chain(cents =>\n      Box(moneyToFloat(p)).map(savings => cents - cents * savings),\n    )\n    .fold(x => x);\n};\n")),Object(a.b)("h2",{id:"either-monad"},"Either Monad"),Object(a.b)("p",null,'This "box" is going to be a Functor that has a map method and a Monad that has a chain method and it is going to foldable.'),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const findColor = name => ({ red: '#ff4444', blue: '#3b5988' }[name]);\n\nconst res = findColor('red').toUpperCase();\nconst res2 = findColor('redd').toUpperCase(); // uh-oh - how do we deal with this?\n\n// the either monad\nconst Right = x => ({\n  chain: f => f(x),\n  map: f => Right(f(x)),\n  fold: (f, g) => g(x),\n  inspect: `Right(${x})`,\n});\n\nconst Left = x => ({\n  chain: f => Left(f(x)),\n  // this keeps the error bubbling through!\n  map: f => Left(f(x)),\n  fold: (f, g) => f(x),\n  inspect: `Left(${x})`,\n});\n\nconst findColor2 = name => {\n  const found = { red: '#ff4444', blue: '#3b5988' }[name];\n  return found ? Right(found) : Left('dunno');\n};\n\nconst res3 = findColor('red').map(x => x.toUpperCase());\nconst res4 = findColor('redd')\n  .map(x => x.toUpperCase())\n  .fold(() => 'no color!', color => color); // doesn't care - doesn't blow up!\n")),Object(a.b)("p",null,"You can think of ",Object(a.b)("inlineCode",{parentName:"p"},"Right")," and ",Object(a.b)("inlineCode",{parentName:"p"},"Left")," as subclasses of this super class we call ",Object(a.b)("inlineCode",{parentName:"p"},"Either"),". Note that the ",Object(a.b)("inlineCode",{parentName:"p"},"fold")," method on both take a specific function parameter to use."),Object(a.b)("h3",{id:"fromnullable-utility"},"fromNullable utility"),Object(a.b)("p",null,"From nullable can abstract the Either monad subclass."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const fromNullable = x => (x != null ? Right(x) : Left());\nconst findColor3 = name => fromNullabe({ red: '#ff4444', blue: '#3b5988' }[name])\n};\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Note: You don't have to define this stuff yourself. There are libries out there that help us do that.")),Object(a.b)("h2",{id:"refactoring-node-fs-using-the-either-monad"},"Refactoring Node fs using the Either Monad"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"// before\nconst getPort_ = () => {\n  fs.readFileSync('config.json');\n  try {\n    const str = fs.readFileSync('config.json');\n    const config = JSON.parse(str);\n    return config.port;\n  } catch (e) {\n    return 3000;\n  }\n};\n\n// after\nconst tryCatch = f => {\n  try {\n    return Right(f())\n  } else {\n    return Left(e)\n  }\n}\n\nconst getPort1 = () =>\n  tryCatch(fs.readFileSync('config.json')); // assume 3000 in config.json\n  .map(contents =>  JSON.parse(contents))\n  .map(config => config.port)\n  .fold(() => 8080, x => x) // 3000\n\nconst getPort2 = () =>\n  tryCatch(fs.readFileSync('coneaig.json')); // blow up\n  .map(contents =>  JSON.parse(contents))\n  .map(config => config.port)\n  .fold(() => 8080, x => x) // 8080\n\nconst result = getPort();\nconsole.log(result);\n\n// we can abstract further...\nconst readFileSync = path => tryCatch(() => fs.readFileSync(path)); // assume 3000 in config.json\nconst getPort1 = () =>\n  readFileSync('config.json')\n  .map(contents =>  JSON.parse(contents))\n  .map(config => config.port)\n  .fold(() => 8080, x => x) // 3000\n\n// how about if JSON.parse was in a tryCatch?\nconst readFileSync = path => tryCatch(() => fs.readFileSync(path)); // assume 3000 in config.json\nconst parseJSON = contents =>  JSON.parse(contents)\nconst getPort1 = () =>\n  readFileSync('config.json')\n  .chain(contents => parseJSON(contents))\n  .map(config => config.port)\n  .fold(() => 8080, x => x) // 3000\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Adding Syntax vs Generalized Solutions: we can learn to use a syntax that works with all of them but the idea is to stay general and work with those functions.")),Object(a.b)("p",null,"Here was the solution for the first of the Either exercises:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const streetName = user =>\n  fromNullable(user)\n    .chain(user => fromNullable(user.address))\n    .chain(address => fromNullable(address.street))\n    .map(street => street.name)\n    .fold(() => 'no street', x => x);\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"The presenter never uses the Maybe monad (crazy). Also mentioned is that the ",Object(a.b)("inlineCode",{parentName:"p"},"fold")," part shouldn't really be part of the function. The idea is to return the Either monad and allow the user to decide how to handle it with their own implementation of fold. Also interesting is that he mentioned that you cannot flatten an Either and a Maybe (similar to how can't flatten arrays of a different type). You can flatten an Either of an Either or a Maybe of a Maybe.")),Object(a.b)("p",null,"The second exercise:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const parseDbUrl = cfg =>\n  tryCatch() => JSON.parse(cfg)\n  .map(c -> c.url.match(DB_REGEX))\n  .fold(err => null, x => x)\n\n// we could also do\nconst parseDbUrl = cfg =>\n  Right(cfg) // has to be Right and not Left\n  .chain(c => tryCatch(() => JSON.parse(cfg)))\n  .map(c -> c.url.match(DB_REGEX))\n  .fold(err => null, x => x)\n\n// The correct way to handle it.\n// It allows you to interface correctly.\nconst parseDbUrl = cfg =>\n  Either.of(cfg)\n  .chain(c => tryCatch(() => JSON.parse(cfg)))\n  .map(c -> c.url.match(DB_REGEX))\n  .fold(err => null, x => x) // again, you generally don't want to do this from the context\n")),Object(a.b)("h2",{id:"task-monad"},"Task Monad"),Object(a.b)("p",null,"We've seen one way to make a ",Object(a.b)("inlineCode",{parentName:"p"},"Box")," where we map and return a ",Object(a.b)("inlineCode",{parentName:"p"},"Box(element)"),", but there is another way to go and that is to take a function."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const Box = f => ({\n  map: g =>\n    Box(\n      compose(\n        f,\n        g,\n      ),\n    ),\n  fold: f,\n});\n\nBox(() => 2)\n  .map(two => two + 1)\n  .fold(); // 2\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"This is the basis of the Reader Monad. Knowing you can make a functor lazy by using a composition is a really useful thing to know.")),Object(a.b)("p",null,"So armed with this knowledge, let's move onto ",Object(a.b)("inlineCode",{parentName:"p"},"Task")," that maps in a similar way."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"// The definition from the types file\nconst Task = fork => ({\n  fork,\n  ap: other =>\n    Task((rej, res) => fork(rej, f => other.fork(rej, x => res(f(x))))),\n  map: f => Task((rej, res) => fork(rej, x => res(f(x)))),\n  chain: f => Task((rej, res) => fork(rej, x => f(x).fork(rej, res))),\n  concat: other =>\n    Task((rej, res) =>\n      fork(rej, x =>\n        other.fork(rej, y => {\n          console.log('X', x, 'Y', y);\n          res(x.concat(y));\n        }),\n      ),\n    ),\n  fold: (f, g) =>\n    Task((rej, res) =>\n      fork(x => f(x).fork(rej, res), x => g(x).fork(rej, res)),\n    ),\n});\nTask.of = x => Task((rej, res) => res(x));\nTask.rejected = x => Task((rej, res) => rej(x));\nTask.fromPromised = fn => (...args) =>\n  Task((rej, res) =>\n    fn(...args)\n      .then(res)\n      .catch(rej),\n  );\n\n// What is shown in the tutorial\nTask.of(2).map(two => two + 1); // Task(2)\n// Notice: this won't run (not due to error).\nconst t1 = Task((rej, res) => res(2))\n  .map(two => two + 1)\n  .map(three => three * 2);\n\n// like fold, but fork because it will run stuff\nt1.fork(console.error, console.log); // 6\n")),Object(a.b)("h3",{id:"refactoring-node-io-with-task"},"Refactoring Node IO with Task"),Object(a.b)("p",null,"We're going to refactor this bad boy:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const fs = require('fs');\n\nconst app = () =>\n  fs.readFile('config.json', 'utf-8', (err, contents) => {\n    console.log(err, contents);\n    if (err) throw err;\n\n    const newContents = contents.replace(/3/g, '6');\n\n    fs.writeFile('config1.json', newContents, (err, _) => {\n      if (err) throw err;\n      console.log('success!');\n    });\n  });\n\napp();\n")),Object(a.b)("p",null,"Note, we're using Task since it does everything that IO will do but async. Using the Task, we can update to this:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const { Task } = require('../types');\nconst fs = require('fs');\n\nconst readFile = (path, enc) =>\n  Task((rej, res) =>\n    fs.readFile(path, enc, (err, contents) => (err ? rej(err) : res(contents))),\n  );\n\nconst writeFile = (path, enc) =>\n  Task((rej, res) =>\n    fs.writeFile(path, enc, (err, contents) =>\n      err ? rej(err) : res(contents),\n    ),\n  );\n\nconst app = () =>\n  readFile('config.json', 'utf-8') // Task(contents)\n    .map(contents => contents.replace(/3/g, '6')) // Task(Task(contents))\n    .chain(newContents => writeFile('config.json', newContents));\n\napp().fork(console.error, () => console.log('Success'));\n")),Object(a.b)("h2",{id:"task-practices"},"Task Practices"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Note around here was that when talking Tasks during the practice questions, Brian refers to Monads as being pointed functors that don't just have chain but also an ",Object(a.b)("inlineCode",{parentName:"p"},"of")," method.")),Object(a.b)("p",null,"An interesting example at the end:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const httpGet = (path, params) => Task.of(`${path}: result`);\n\nconst getUser = x => httpGet('/user', { id: x });\nconst getTimeline = x => httpGet('/timeline/${x}', {});\nconst getAds = () => httpGet('/ads', {});\n\n// with promises you could...\nPromise.all([getUser, getTimeline, getAds]); // [Promise]\n\n// using tasks - this traverse and List come from Brian's library\n// this gives us back a Promise[]\nList([getUser, getTimeline, getAds])\n  .traverse(Task.of, f => f())\n  .fork(console.log, x => console.log(x.toJS()));\n")),Object(a.b)("h2",{id:"transforms-and-monad-patterns"},"Transforms and Monad Patterns"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Something interesting that came up here was when there was a ",Object(a.b)("inlineCode",{parentName:"p"},"Either(List(Either))")," and Brian mentioned that if we swapped List and Either then we could squash them down. He doesn't show this in the course.")),Object(a.b)("h2",{id:"creating-a-weather-module"},"Creating a Weather Module"),Object(a.b)("p",null,"Notes from while he is doing the tasks:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"He is packaging up the arguments into one."),Object(a.b)("li",{parentName:"ul"},"There is a use case he doesn't going into during the exercise with a Writer monad."),Object(a.b)("li",{parentName:"ul"},"Brian creates a Weather data type when updating to functional programming.")),Object(a.b)("h2",{id:"qa"},"Q&A"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Left or Right comes from the mathmetical history in Category Theory."),Object(a.b)("li",{parentName:"ul"},"Brian mentions that a lot of the naming comes from the math history and is about not ignoring the docs."),Object(a.b)("li",{parentName:"ul"},"Brian recommends learning imperative before declarative program."),Object(a.b)("li",{parentName:"ul"},"RxJS is mentioned as being purely functional.")))}l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"manual/Functional-Programming/Hardcore-FP-In-JavaScript-v2.md"}}),l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---manual-functional-programming-hardcore-fp-in-java-script-v-2-md-513c5cf1e80f6e090fa2.js.map