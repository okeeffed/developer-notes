(window.webpackJsonp=window.webpackJsonp||[]).push([[281],{"e+DC":function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return i})),n.d(t,"default",(function(){return c}));n("1c7q"),n("abGl"),n("gZHo"),n("Fdmb"),n("Ir+3"),n("2mQt"),n("mXGw");var r=n("/FXl"),o=n("TjRS");n("aD51");function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var i={};void 0!==i&&i&&i===Object(i)&&Object.isExtensible(i)&&!i.hasOwnProperty("__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"manual/GraphQL/Advanced-GraphQL-v2.md"}});var s={_frontmatter:i},l=o.a;function c(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,["components"]);return Object(r.b)(l,a({},s,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"advanced-graphql-v2"},"Advanced GraphQL v2"),Object(r.b)("h2",{id:"resources"},"Resources"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",a({parentName:"li"},{href:"https://frontendmasters.com/courses/advanced-graphql-v2/"}),"Advanced GraphQL course")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",a({parentName:"li"},{href:"https://github.com/FrontendMasters/advanced-gql-v2"}),"Course Materials - GitHub")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",a({parentName:"li"},{href:"https://github.com/FrontendMasters/advanced-gql-v2/tree/solution/src"}),"Course Solutions - GitHub")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",a({parentName:"li"},{href:"https://docs.google.com/presentation/d/1DaTDx2Jdolkws2xPx44ee6WuQYMiIAyaaEmN-IBaW1s/edit#slide=id.g62311a3d9f_0_5"}),"Course Slides")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",a({parentName:"li"},{href:"https://graphql.org/graphql-js/mutations-and-input-types/"}),"GraphQL Mutations and Input Types")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",a({parentName:"li"},{href:"https://www.apollographql.com/docs/graphql-tools/resolvers/"}),"GraphQL Resolvers")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",a({parentName:"li"},{href:"https://graphql.org/learn/execution/#root-fields-resolvers"}),"GraphQL Context")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",a({parentName:"li"},{href:"https://github.com/APIs-guru/graphql-lodash"}),"GraphQL Lodash library"))),Object(r.b)("h2",{id:"introduction"},"Introduction"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"GraphQL is a spec that describes a declarative query language that your clients can use to ask an API for the exact data they want. This is achieved by creating a strongly typed Schema for your API, ultimate flexibility in how your API can resolve data and client queries validated against your Schema. - Course definition.")),Object(r.b)("p",null,"The main parts:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Type Definitions"),Object(r.b)("li",{parentName:"ol"},"Resolvers"),Object(r.b)("li",{parentName:"ol"},"Schema"),Object(r.b)("li",{parentName:"ol"},"Data Sources")),Object(r.b)("p",null,"Tools and libs:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"graphql-js"),Object(r.b)("li",{parentName:"ul"},"Apollo Server"),Object(r.b)("li",{parentName:"ul"},"Express"),Object(r.b)("li",{parentName:"ul"},"GraphQL Playground")),Object(r.b)("h2",{id:"create-a-graphql-server"},"Create a GraphQL Server"),Object(r.b)("h3",{id:"type-definitions"},"Type Definitions"),Object(r.b)("p",null,"Example type definitions we are creating:"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),'const gql = require(\'graphql-tag\');\n\nmodule.exports = gql`\n  directive @log(format: String) on FIELD_DEFINITION\n  directive @formatDate(format: String = "d, MMM, yyyy") on FIELD_DEFINITION\n  enum Theme {\n    DARK\n    LIGHT\n  }\n  enum Role {\n    ADMIN\n    MEMBER\n    GUEST\n  }\n  type User {\n    id: ID! @log(format: "hello")\n    email: String!\n    avatar: String!\n    verified: Boolean!\n    createdAt: String! @formatDate\n    posts: [Post]!\n    role: Role!\n    settings: Settings!\n  }\n  type AuthUser {\n    token: String!\n    user: User!\n  }\n  type Post {\n    id: ID!\n    message: String!\n    author: User!\n    createdAt: String!\n    likes: Int!\n    views: Int!\n  }\n  type Settings {\n    id: ID!\n    user: User!\n    theme: Theme!\n    emailNotifications: Boolean!\n    pushNotifications: Boolean!\n  }\n  type Invite {\n    email: String!\n    from: User!\n    createdAt: String!\n    role: Role!\n  }\n  input NewPostInput {\n    message: String!\n  }\n  input UpdateSettingsInput {\n    theme: Theme\n    emailNotifications: Boolean\n    pushNotifications: Boolean\n  }\n  input UpdateUserInput {\n    email: String\n    avatar: String\n    verified: Boolean\n  }\n  input InviteInput {\n    email: String!\n    role: Role!\n  }\n  input SignupInput {\n    email: String!\n    password: String!\n    role: Role!\n  }\n  input SigninInput {\n    email: String!\n    password: String!\n  }\n  type Query {\n    me: User!\n    posts: [Post]!\n    post(id: ID!): Post!\n    userSettings: Settings!\n    feed: [Post]!\n  }\n  type Mutation {\n    updateSettings(input: UpdateSettingsInput!): Settings!\n    createPost(input: NewPostInput!): Post!\n    updateMe(input: UpdateUserInput!): User\n    invite(input: InviteInput!): Invite!\n    signup(input: SignupInput!): AuthUser!\n    signin(input: SigninInput!): AuthUser!\n  }\n  type Subscription {\n    newPost: Post\n  }\n`;\n')),Object(r.b)("p",null,"For more information on the ",Object(r.b)("inlineCode",{parentName:"p"},"mutation")," and ",Object(r.b)("inlineCode",{parentName:"p"},"input")," types, check the ",Object(r.b)("a",a({parentName:"p"},{href:"https://graphql.org/graphql-js/mutations-and-input-types/"}),"GraphQL docs"),"."),Object(r.b)("h3",{id:"resolvers"},"Resolvers"),Object(r.b)("p",null,"We can then declare resolvers to handle the Queries, Mutations etc."),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"const { AuthenticationError } = require('apollo-server');\nconst { PubSub } = require('apollo-server');\nconst { authenticated, authorized } = require('./auth');\n\nconst pubsub = new PubSub();\nconst NEW_POST = 'NEW_POST';\n\n/**\n * Anything Query / Mutation resolver\n * using a user for a DB query\n * requires user authenication\n */\nmodule.exports = {\n  Query: {\n    me: authenticated((_, __, { user }) => {\n      return user;\n    }),\n    posts: authenticated((_, __, { user, models }) => {\n      return models.Post.findMany({ author: user.id });\n    }),\n\n    post: authenticated((_, { id }, { user, models }) => {\n      return models.Post.findOne({ id, author: user.id });\n    }),\n\n    userSettings: authenticated((_, __, { user, models }) => {\n      return models.Settings.findOne({ user: user.id });\n    }),\n    // public resolver\n    feed(_, __, { models }) {\n      return models.Post.findMany();\n    },\n  },\n  Mutation: {\n    updateSettings: authenticated((_, { input }, { user, models }) => {\n      return models.Settings.updateOne({ user: user.id }, input);\n    }),\n\n    createPost: authenticated((_, { input }, { user, models }) => {\n      const post = models.Post.createOne({ ...input, author: user.id });\n      pubsub.publish(NEW_POST, { newPost: post });\n      return post;\n    }),\n\n    updateMe: authenticated((_, { input }, { user, models }) => {\n      return models.User.updateOne({ id: user.id }, input);\n    }),\n    // admin role\n    invite: authenticated(\n      authorized('ADMIN', (_, { input }, { user }) => {\n        return {\n          from: user.id,\n          role: input.role,\n          createdAt: Date.now(),\n          email: input.email,\n        };\n      }),\n    ),\n\n    signup(_, { input }, { models, createToken }) {\n      const existing = models.User.findOne({ email: input.email });\n\n      if (existing) {\n        throw new AuthenticationError('nope');\n      }\n      const user = models.User.createOne({\n        ...input,\n        verified: false,\n        avatar: 'http',\n      });\n      const token = createToken(user);\n      models.Settings.createOne({\n        user: user.id,\n        theme: 'DARK',\n        emailNotifications: true,\n        pushNotifications: true,\n      });\n      return { token, user };\n    },\n    signin(_, { input }, { models, createToken }) {\n      const user = models.User.findOne(input);\n\n      if (!user) {\n        throw new AuthenticationError('wrong email + password combo');\n      }\n\n      const token = createToken(user);\n\n      return { token, user };\n    },\n  },\n  Subscription: {\n    newPost: {\n      subscribe: () => pubsub.asyncIterator(NEW_POST),\n    },\n  },\n  User: {\n    posts(root, _, { user, models }) {\n      if (root.id !== user.id) {\n        throw new AuthenticationError('not your posts');\n      }\n\n      return models.Post.findMany({ author: root.id });\n    },\n    settings(root, __, { user, models }) {\n      return models.Settings.findOne({ id: root.settings, user: user.id });\n    },\n  },\n  Settings: {\n    user(settings, _, { user, models }) {\n      return models.Settings.findOne({ id: settings.id, user: user.id });\n    },\n  },\n  Post: {\n    author(post, _, { models }) {\n      return models.User.findOne({ id: post.author });\n    },\n  },\n};\n")),Object(r.b)("p",null,"You can read more on Resolvers on the ",Object(r.b)("a",a({parentName:"p"},{href:"https://www.apollographql.com/docs/graphql-tools/resolvers/"}),"GraphQL docs"),"."),Object(r.b)("h2",{id:"authentication"},"Authentication"),Object(r.b)("p",null,"Authorization:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Should not be coupled to a resolver."),Object(r.b)("li",{parentName:"ol"},"Can provide field level custom rules."),Object(r.b)("li",{parentName:"ol"},"Can authorize some of your schema and not all.")),Object(r.b)("p",null,"Authentication:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Providers the users to resolvers."),Object(r.b)("li",{parentName:"ol"},"Should not be coupled to a resolver."),Object(r.b)("li",{parentName:"ol"},"Can protect some of your Schema and not all of it."),Object(r.b)("li",{parentName:"ol"},"Can provide field level protection.")),Object(r.b)("h3",{id:"auth-approaches"},"Auth Approaches"),Object(r.b)("p",null,"How to auth:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Outside of GraphQL: On the server prior to execution."),Object(r.b)("li",{parentName:"ol"},"When creating context: On initialisation of the server. Can access the incoming request to determine authentication. Not extra work to pass to GraphQL resolvers."),Object(r.b)("li",{parentName:"ol"},"Inside the resolvers: Encapsulated on each resolver (note that it should not be).")),Object(r.b)("h4",{id:"outside-of-graphql"},"Outside of GraphQL"),Object(r.b)("p",null,"The downside is it completely locks down all GraphQL queries and mutations. Extra complexity as well as need to pass auth info to GraphQL."),Object(r.b)("h4",{id:"when-creating-context"},"When Creating Context"),Object(r.b)("p",null,"For the creation of context, that can happen right at the server:"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"const server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  // whatever is put here will be returned\n  // as the third argument in a resolver.\n  // This could give us access to Express req etc.\n  context({req}) {\n      const token = req.headers.authorization\n      const user = getUserFromToken(token)\n      return {\n        {...db, user, createToken}\n    }\n  }\n})\n\nserver.listen().then({url} => console.log('Server running'))\n\n// then in the resolvers file\n// code omitted for brevity\nmodule.exports = {\nMutation: {\n     // 3rd arg is the CONTEXT\n    updateSettings(_, { input }, { user, models }) {\n      return models.Settings.updateOne({ user: user.id }, input);\n    },\n}\n")),Object(r.b)("p",null,"Read more about ",Object(r.b)("inlineCode",{parentName:"p"},"context")," on the ",Object(r.b)("a",a({parentName:"p"},{href:"https://graphql.org/learn/execution/#root-fields-resolvers"}),"GraphQL Docs"),"."),Object(r.b)("h4",{id:"inside-resolvers"},"Inside Resolvers"),Object(r.b)("p",null,"Ties the business logic too close to the authentication logic. Not a good use of separation of concerns."),Object(r.b)("h2",{id:"authentication-example"},"Authentication Example"),Object(r.b)("p",null,"Here is an example of using authentication:"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"const { AuthenticationError } = require('apollo-server');\n\nconst jwt = require('jsonwebtoken');\nconst { models } = require('./db');\nconst secret = 'catpack';\n\nconst createToken = ({ id, role }) => jwt.sign({ id, role }, secret);\n\nconst getUserFromToken = token => {\n  try {\n    const user = jwt.verify(token, secret);\n    return models.User.findOne({ id: user.id });\n  } catch (e) {\n    return null;\n  }\n};\n\nconst authenticated = next => (root, args, context, info) => {\n  if (!context.user) {\n    throw new AuthenticationError('must authenticate');\n  }\n\n  return next(root, args, context, info);\n};\n\nconst authorized = (role, next) => (root, args, context, info) => {\n  if (context.user.role !== role) {\n    throw new AuthenticationError(`you must have ${role} role`);\n  }\n\n  return next(root, args, context, info);\n};\n\nmodule.exports = {\n  getUserFromToken,\n  authenticated,\n  authorized,\n  createToken,\n};\n")),Object(r.b)("p",null,"When using it in our resolvers, we can then run the following."),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"const { AuthenticationError } = require('apollo-server');\nconst { PubSub } = require('apollo-server');\nconst { authenticated, authorized } = require('./auth');\n\nconst pubsub = new PubSub();\nconst NEW_POST = 'NEW_POST';\n\n/**\n * Anything Query / Mutation resolver\n * using a user for a DB query\n * requires user authenication\n */\nmodule.exports = {\n  Query: {\n    me: authenticated((_, __, { user }) => {\n      return user;\n    }),\n  },\n};\n")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"There was a question about whether to use directives instead for authentication, with the answer comparing their simularities but the advantage is you won't need to wrap all your resolvers, which gives the benefit of less code.")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"Another great question was to use the wrappers to operate like Middleware that can also handle things like schema validations that GraphQL's built-in type cannot.")),Object(r.b)("h2",{id:"subscriptions-in-graphql"},"Subscriptions in GraphQL"),Object(r.b)("p",null,"There are two options for real-time with GraphQL:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Subscriptions - A well supported GraphQL operation that's useful for notifiying clients of events."),Object(r.b)("li",{parentName:"ol"},"Live Queries - Client side implementation to be notified when data changes.")),Object(r.b)("p",null,"Nothing stops you from using other real-time solutions, but these two are the ones built into GraphQL."),Object(r.b)("p",null,"Subscriptions vs Live Queries:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Subscriptions are part of the spec"),Object(r.b)("li",{parentName:"ul"},"Subscriptions are concerned on event observations (as opposed to data changes)"),Object(r.b)("li",{parentName:"ul"},"Subscriptions have great support"),Object(r.b)("li",{parentName:"ul"},"LQ are experimental (coming from the GraphQL spec)"),Object(r.b)("li",{parentName:"ul"},"LQ concerned on data observation"),Object(r.b)("li",{parentName:"ul"},"LQ support is getting there"),Object(r.b)("li",{parentName:"ul"},"Both are flexible transports and protocols (websockets, polling, SSE all supported)"),Object(r.b)("li",{parentName:"ul"},"Both have predictable responses")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},'"Just use subscriptions" - Course runner.')),Object(r.b)("p",null,"The why subscriptions:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Use if manual refetching and polling have too high of a latency cost (chat apps)"),Object(r.b)("li",{parentName:"ul"},"Initial state being huge but changes are small"),Object(r.b)("li",{parentName:"ul"},"LQ is just not there yet")),Object(r.b)("p",null,"Adding subscription support:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Subscriptions must be added to your Schema like Queries of Mutations"),Object(r.b)("li",{parentName:"ul"},"Setup PubSub protocol server side"),Object(r.b)("li",{parentName:"ul"},"Create Subscription event resolvers"),Object(r.b)("li",{parentName:"ul"},"Add any needed authentication and context"),Object(r.b)("li",{parentName:"ul"},"Client side setup")),Object(r.b)("p",null,"Example subscription from our ",Object(r.b)("inlineCode",{parentName:"p"},"resolvers.js")," file:"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"const { PubSub } = require('apollo-server');\n\nmodule.exports = {\n  Mutation: {\n    // publish the event to the pubsub from here\n    createPost: authenticated((_, { input }, { user, models }) => {\n      const post = models.Post.createOne({ ...input, author: user.id });\n      // must pass the payload to the client\n      pubsub.publish(NEW_POST, { newPost: post });\n      return post;\n    }),\n  },\n  Subscription: {\n    newPost: {\n      // `asyncIterator just allows you to process things\n      // one at a time asynchronously\n      subscribe: () => pubsub.asyncIterator(NEW_POST),\n    },\n  },\n};\n")),Object(r.b)("p",null,"As for the server we need to pass ",Object(r.b)("inlineCode",{parentName:"p"},"connection")," property and handle the context creation a little differently to pass the connection context."),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"const server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  schemaDirectives: {\n    log: LogDirective,\n    formatDate: FormatDateDirective,\n  },\n  context({ connection }) {\n    // passing connection context\n    if (connection) {\n      return { ...connection.context };\n    }\n\n    const token = req.headers.authorization;\n    const user = getUserFromToken(token);\n    return { ...db, user, createToken };\n  },\n  subscriptions: {\n    // used to get `connectParams` and set connection for context\n    onConnect(connectionParams) {\n      if (connectionParams.auth) {\n        const user = getUserFromToken(connectionParams.auth);\n\n        // handled error happened here\n        if (!user) {\n          throw new AuthenticationError('not authenticated');\n        }\n\n        return { user };\n      }\n\n      throw new AuthenticationError('not authenticated');\n    },\n  },\n});\n")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"When demoing subscriptions in the UI, it is important that you need to run Graphiql in two different tabs. One that subscribes, the other that can make the mutation.")),Object(r.b)("h2",{id:"error-handling"},"Error Handling"),Object(r.b)("p",null,"If you throw errors, GraphQL will ensure they are caught. In the context of GraphQL, any error will be caught and passed back in the query."),Object(r.b)("p",null,"The query will give back an errors property with an array of errors that contain things including the error name and stack trace etc."),Object(r.b)("p",null,"The response can contain errors or data."),Object(r.b)("p",null,"If you are in production mode, the stacktrace won't be passed in the response when using Apollo."),Object(r.b)("p",null,"Note that Apollo has its own errors exposed from the API that you can extend."),Object(r.b)("h3",{id:"formatting-and-error-codes"},"Formatting and Error Codes"),Object(r.b)("p",null,"You can also intercept and change errors from the ",Object(r.b)("inlineCode",{parentName:"p"},"ApolloServer")," using the ",Object(r.b)("inlineCode",{parentName:"p"},"formatError")," object method."),Object(r.b)("p",null,"Here is a good spot to use something like Sentry etc to help filter what errors to send to Sentry."),Object(r.b)("h2",{id:"testing"},"Testing"),Object(r.b)("p",null,"Testing resolvers:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Unit test resolver functions."),Object(r.b)("li",{parentName:"ul"},"Mock out data sources."),Object(r.b)("li",{parentName:"ul"},"Mock out DB calls.")),Object(r.b)("p",null,"Testing schema:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Convert TypeDefs into Schema."),Object(r.b)("li",{parentName:"ul"},"Unit test Object types."),Object(r.b)("li",{parentName:"ul"},"Not a lot of people unit test their schema.")),Object(r.b)("p",null,"Testing the server:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Integration testing the entire server."),Object(r.b)("li",{parentName:"ul"},"Create a test client to use to issue queries and mutations with against a testing instance of your server."),Object(r.b)("li",{parentName:"ul"},"Mock out whatever you want. Variables, constants etc.")),Object(r.b)("h3",{id:"testing-example"},"Testing Example"),Object(r.b)("p",null,"There is a helper for setting up the server in the ",Object(r.b)("inlineCode",{parentName:"p"},"tests")," directory."),Object(r.b)("p",null,"Because the schema is typed, it makes it very easy to turn on mocks! This means you don't have to wait for the end users."),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"const { ApolloServer } = require('apollo-server');\nconst { createTestClient } = require('apollo-server-testing');\nconst typeDefs = require('../src/typedefs');\nconst resolvers = require('../src/resolvers');\n\nconst createTestServer = ctx => {\n  const server = new ApolloServer({\n    typeDefs,\n    resolvers,\n    // these two are closely tied\n    mockEntireSchema: false,\n    mocks: true,\n    context: () => ctx,\n  });\n\n  return createTestClient(server);\n};\n\nmodule.exports = createTestServer;\n")),Object(r.b)("p",null,"As for the test itself, you can see an example here:"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// query.test.js\nconst gql = require('graphql-tag');\nconst createTestServer = require('./helper');\nconst FEED = gql`\n  {\n    feed {\n      id\n      message\n      createdAt\n      likes\n      views\n    }\n  }\n`;\n\ndescribe('queries', () => {\n  test('feed', async () => {\n    // this is where the test server will\n    // take an object\n    const { query } = createTestServer({\n      user: { id: 1 },\n      models: {\n        Post: {\n          findMany: jest.fn(() => [\n            {\n              id: 1,\n              message: 'hello',\n              createdAt: 12345839,\n              likes: 20,\n              views: 300,\n            },\n          ]),\n        },\n      },\n    });\n\n    const res = await query({ query: FEED });\n    expect(res).toMatchSnapshot();\n  });\n});\n")),Object(r.b)("h2",{id:"directives"},"Directives"),Object(r.b)("p",null,"Allow you to add logic and metadata to your Schemas, Queries or Mutations. Can act like middleware for Schemas, or post processing hooks for your Queries and Mutations."),Object(r.b)("p",null,"Why use directives?"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Fine-grain control down to the field level on your ",Object(r.b)("inlineCode",{parentName:"li"},"TypeDefs"),"."),Object(r.b)("li",{parentName:"ul"},"Eliminate post processing on your clients after you query."),Object(r.b)("li",{parentName:"ul"},"Extendable. Can have directives use directives etc.")),Object(r.b)("h3",{id:"directives-on-the-server-side"},"Directives on the Server Side"),Object(r.b)("p",null,"For example, using the deprecate, formatDate and log directive - one from GraphQL, the other two that we declare:"),Object(r.b)("p",null,"Directives can go on a property (as seen below) or even on a type ie ",Object(r.b)("inlineCode",{parentName:"p"},"type User @deprecate { ... }"),"."),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),'const gql = require(\'graphql-tag\');\n\nmodule.exports = gql`\n  directive @log(format: String) on FIELD_DEFINITION\n  directive @formatDate(format: String = "d, MMM, yyyy") on FIELD_DEFINITION\n  enum Theme {\n    DARK\n    LIGHT\n  }\n  enum Role {\n    ADMIN\n    MEMBER\n    GUEST\n  }\n  type User {\n    id: ID! @log(format: "hello")\n    email: String! @deprecated\n    avatar: String!\n    verified: Boolean!\n    createdAt: String! @formatDate\n    posts: [Post]!\n    role: Role!\n    settings: Settings!\n  }\n`;\n')),Object(r.b)("p",null,"This then also helps support our GraphQL docs."),Object(r.b)("p",null,"Note that ",Object(r.b)("inlineCode",{parentName:"p"},"@deprected")," takes an argument ie ",Object(r.b)("inlineCode",{parentName:"p"},'@deprecated(reason: "use another field")'),"."),Object(r.b)("h3",{id:"clientside-directives"},"Clientside Directives"),Object(r.b)("p",null,"Front the client query, we can add clientside directives."),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-graphql"}),"query GetMe($yes: Boolean!) {\n  me {\n    # based on query variables\n    error @include(if: $yes)\n    username\n    createdAt\n  }\n}\n")),Object(r.b)("p",null,"There is a ",Object(r.b)("a",a({parentName:"p"},{href:"https://github.com/APIs-guru/graphql-lodash"}),"library")," that can even do Lodash changes to your queries from the clientside."),Object(r.b)("h2",{id:"creating-directives"},"Creating Directives"),Object(r.b)("p",null,"Can be challenging if you're unfamiliar with how GraphQL works. You will need to work with the AST."),Object(r.b)("p",null,"It also requires a definition in your schema."),Object(r.b)("p",null,"Finally, you need to create logic for your Directive to use."),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),'// the rest is omitted for brevity.\nmodule.exports = gql`\n  directive @log(format: String) on FIELD_DEFINITION\n  directive @formatDate(format: String = "d, MMM, yyyy") on FIELD_DEFINITION\n`;\n')),Object(r.b)("p",null,"The, we can define the logic for our directive:"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"const { SchemaDirectiveVisitor } = require('apollo-server');\nconst { defaultFieldResolver, GraphQLString } = require('graphql');\nconst { formatDate } = require('./utils');\n\nclass LogDirective extends SchemaDirectiveVisitor {\n  visitFieldDefinition(field, type) {\n    const { resolve = defaultFieldResolver } = field;\n\n    field.resolve = async function(root, { format, ...rest }, ctx, info) {\n      console.log(`⚡️  ${type.objectType}.${field.name}`);\n      return resolve.call(this, root, rest, ctx, info);\n    };\n  }\n}\n\nclass FormatDateDirective extends SchemaDirectiveVisitor {\n  visitFieldDefinition(field) {\n    const { resolve = defaultFieldResolver } = field;\n    const { format: defaultFormat } = this.args;\n\n    field.args.push({\n      name: 'format',\n      type: GraphQLString,\n    });\n\n    field.resolve = async function(root, { format, ...rest }, ctx, info) {\n      const date = await resolve.call(this, root, rest, ctx, info);\n      return formatDate(date, format || defaultFormat);\n    };\n  }\n}\n\nmodule.exports = { LogDirective, FormatDateDirective };\n")),Object(r.b)("p",null,"For the server, you need to make sure you link the directives for this to all work."),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"const server = new ApolloServer({\n  // rest omitted for brevity\n  schemaDirectives: {\n    log: LogDirective,\n    formatDate: FormatDateDirective,\n  },\n});\n")),Object(r.b)("p",null,"We can use ",Object(r.b)("inlineCode",{parentName:"p"},"defaultFieldResolver")," from ",Object(r.b)("inlineCode",{parentName:"p"},"graphql")," which takes a value, looks at the keys and if the keys match the field, it returns that."),Object(r.b)("p",null,"This is used to make sure our definition logs when it is called instead of on startup:"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"visitFieldDefinition(field, type) {\n  // guves access to old resolver or using the default one\n  const { resolve = defaultFieldResolver } = field;\n\n  field.resolve = async function(root, { format, ...rest }, ctx, info) {\n    console.log(`⚡️  ${type.objectType}.${field.name}`);\n    return resolve.call(this, root, rest, ctx, info);\n  };\n}\n")),Object(r.b)("p",null,"Directives can also take a string as an argument. In fact, we can set the directive to take args from the query params:"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"const { SchemaDirectiveVisitor } = require('apollo-server');\nconst { defaultFieldResolver, GraphQLString } = require('graphql');\n\nclass FormatDateDirective extends SchemaDirectiveVisitor {\n  visitFieldDefinition(field) {\n    const { resolve = defaultFieldResolver } = field;\n    const { format: defaultFormat } = this.args;\n\n    field.args.push({\n      name: 'format',\n      type: GraphQLString,\n    });\n\n    field.resolve = async function(root, { format, ...rest }, ctx, info) {\n      const date = await resolve.call(this, root, rest, ctx, info);\n      return formatDate(date, format || defaultFormat);\n    };\n  }\n}\n")),Object(r.b)("h2",{id:"example-auth-directive"},"Example Auth Directive"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"class AuthenticationDirective extends SchemaDirectiveVisitor {\n  visitFieldDefinition(field) {\n    const resolver = field.resolve || defaultFieldResolver;\n    field.resolve = async (root, args, ctx, info) => {\n      if (!ctx.user) {\n        throw new AuthenticationError('not auth');\n      }\n      return resolver(root, args, ctx, info);\n    };\n  }\n}\n\nclass AuthorizationDirective extends SchemaDirectiveVisitor {\n  visitFieldDefinition(field) {\n    const resolver = field.resolve || defaultFieldResolver;\n    const { role } = this.args;\n\n    field.resolve = async (root, args, ctx, info) => {\n      if (ctx.user.role !== role) {\n        throw new AuthenticationError('wrong role');\n      }\n      return resolver(root, args, ctx, info);\n    };\n  }\n}\n")),Object(r.b)("p",null,"Then in the GraphQL Tag:"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"module.exports = gql`\n  directive @authenticated on FIELD_DEFINITION\n  directive @authorized(role: Role!) on FIELD_DEFINITION\n`;\n")),Object(r.b)("p",null,"Finally, we add it onto the server:"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"const server = new ApolloServer({\n  // rest omitted for brevity\n  schemaDirectives: {\n    authentication: AuthenticationDirective,\n    authorization: AuthorizationDirective,\n  },\n});\n")),Object(r.b)("p",null,"You can then use it in a GraphQL theory like so:"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-graphql"}),"module.exports = gql`\n  type Query {\n    me: User! @authenticated @authorized(role: ADMIN)\n    posts: [Post]!\n    post(id: ID!): Post!\n    userSettings: Settings!\n    feed: [Post]!\n  }\n`\n")),Object(r.b)("p",null,"Note that the directives can be added to type definitions as well!"),Object(r.b)("h2",{id:"caching"},"Caching"),Object(r.b)("p",null,"There is:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Application Caching (DB, external data source, resolvers)"),Object(r.b)("li",{parentName:"ol"},"Network Caching (HTTP caching)"),Object(r.b)("li",{parentName:"ol"},"Client-side Caching")),Object(r.b)("p",null,"Application Caching is the preferred way to cache GraphQL right now. Have many options and levels to cache depending on your server."),Object(r.b)("p",null,"A bunch of misunderstandings around HTTP caching and GraphQL. This can be complicated if you're not using..."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Apollo Cache Control"),Object(r.b)("li",{parentName:"ul"},"Engine"),Object(r.b)("li",{parentName:"ul"},"Automatic Persisted Queries")),Object(r.b)("p",null,"A persisted query is that you build all the queries at runtime and send it to the server. The server prevalidates and stores them on a DB somewhere."),Object(r.b)("p",null,"You get that for free with Apollo if you're using the client and the server packages. You can also use edge applications to program your own cache logic. Examples being Lambda Edge, CloudFlare Edge etc."),Object(r.b)("p",null,"You can also handle or restrict Mutations over ",Object(r.b)("inlineCode",{parentName:"p"},"/GET"),"."),Object(r.b)("h3",{id:"client-side-caching"},"Client side caching"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Apollo client handles this well"),Object(r.b)("li",{parentName:"ul"},"Use any client-side state management (Redux, RxJS etc)"),Object(r.b)("li",{parentName:"ul"},"Persisted Queries in coordination with the server")),Object(r.b)("h3",{id:"how-should-you-cache"},"How should you cache?"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"If you are able to use HTTP caching, enable it"),Object(r.b)("li",{parentName:"ul"},"Cache external HTTP data sources"),Object(r.b)("li",{parentName:"ul"},"Cache client-side")),Object(r.b)("h2",{id:"conclusion-and-qa"},"Conclusion and Q&A"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Are directions part of the GraphQL spec? Yes."),Object(r.b)("li",{parentName:"ol"},"How does he feel about Apollo Federation? Speaker sounds impressed."),Object(r.b)("li",{parentName:"ol"},'How do you limit query length? Security. GitHub counts how many nodes per interval. There is a really nice GraphQL blog for this on "how to GraphQL".'),Object(r.b)("li",{parentName:"ol"},"Does Apollo have a data valiation directive? No but there is some packages out there.")))}c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"manual/GraphQL/Advanced-GraphQL-v2.md"}}),c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---manual-graph-ql-advanced-graph-ql-v-2-md-25181450db33d5d96cf0.js.map