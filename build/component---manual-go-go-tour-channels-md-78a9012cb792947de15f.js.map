{"version":3,"sources":["webpack:///../manual/Go/Go-Tour-Channels.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"ofAMO,IAAMA,EAAe,Q,+MAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,oBADR,oBAGA,kIACA,uBAAK,sBAAMC,WAAW,OAAU,CAC5B,UAAa,oBADZ,gHAML,wEACA,mFACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,2BAIL,iLACA,2MACA,iBAAQ,CACN,GAAM,iBADR,iBAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,sZA0BL,gCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,mBADZ,wCAML,iBAAQ,CACN,GAAM,qBADR,qBAGA,6IACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,gCAIL,iIACA,yEAAwD,0BAAYA,WAAW,KAAvB,YAAxD,WACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,4JAcL,iBAAQ,CACN,GAAM,mBADR,mBAGA,yNACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,oBAIL,qBAAG,0BAAYA,WAAW,KAAvB,MAAH,+EACA,qCAAoB,0BAAYA,WAAW,KAAvB,gBAApB,oEACA,0IACA,qOACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,wUAyBL,qCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,mBADZ,sCAaL,iBAAQ,CACN,GAAM,UADR,UAGA,yGACA,oJACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,meA+BL,0DAAyC,0BAAYA,WAAW,KAAvB,WAAzC,6BAA0H,0BAAYA,WAAW,KAAvB,QAA1H,gBAA2L,0BAAYA,WAAW,KAAvB,UAA3L,mEAAiT,0BAAYA,WAAW,KAAvB,OAAjT,UACA,iBAAQ,CACN,GAAM,qBADR,qBAGA,uFACA,sFACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,+FASL,iCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,kcA0BL,iBAAQ,CACN,GAAM,mCADR,oCAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,qzC,sMAyETJ,EAAWK,gBAAiB","file":"component---manual-go-go-tour-channels-md-78a9012cb792947de15f.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"go-tour-channels\"\n    }}>{`Go Tour Channels`}</h1>\n    <p>{`Channels are a typed conduit through which you can send and receive values with the channel operator, <-.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`ch <- v    // Send v to channel ch.\nv := <-ch  // Receive from ch, and\n           // assign value to v.\n`}</code></pre>\n    <p>{`(The data flows in the direction of the arrow.)`}</p>\n    <p>{`Like maps and slices, channels must be created before use:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`ch := make(chan int)\n`}</code></pre>\n    <p>{`By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.`}</p>\n    <p>{`The example code sums the numbers in a slice, distributing the work between two goroutines. Once both goroutines have completed their computation, it calculates the final result.`}</p>\n    <h2 {...{\n      \"id\": \"basic-example\"\n    }}>{`Basic Example`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc sum(s []int, c chan int) {\n    fmt.Println(\"%v\", s)\n    sum := 0\n    for _, v := range s {\n        sum += v\n    }\n    c <- sum // send sum to c\n}\n\nfunc main() {\n    s := []int{7, 2, 8, -9, 4, 0}\n\n    c := make(chan int)\n    go sum(s[:len(s)/2], c)\n    go sum(s[len(s)/2:], c)\n    x, y := <-c, <-c // receive from c\n\n    fmt.Println(x, y, x+y)\n}\n`}</code></pre>\n    <p>{`Prints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`%v [-9 4 0]\n%v [7 2 8]\n-5 17 12\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"buffered-channels\"\n    }}>{`Buffered Channels`}</h2>\n    <p>{`Channels can be buffered. Provide the buffer length as the second argument to make to initialize a buffered channel:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`ch := make(chan int, 100)\n`}</code></pre>\n    <p>{`Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty.`}</p>\n    <p>{`If you overflow the buffer, you'll be hit with a `}<inlineCode parentName=\"p\">{`deadlock`}</inlineCode>{` error.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc main() {\n    ch := make(chan int, 2)\n    ch <- 1\n    ch <- 2\n    fmt.Println(<-ch)\n    fmt.Println(<-ch)\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"range-and-close\"\n    }}>{`Range and Close`}</h2>\n    <p>{`A sender can close a channel to indicate that no more values will be sent. Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression: after`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`v, ok := <-ch\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`ok`}</inlineCode>{` is false if there are no more values to receive and the channel is closed.`}</p>\n    <p>{`The loop for `}<inlineCode parentName=\"p\">{`i := range c`}</inlineCode>{` receives values from the channel repeatedly until it is closed.`}</p>\n    <p>{`Note: Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic.`}</p>\n    <p>{`Another note: Channels aren't like files; you don't usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a range loop.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n)\n\nfunc fibonacci(n int, c chan int) {\n    x, y := 0, 1\n    for i := 0; i < n; i++ {\n        c <- x\n        x, y = y, x+y\n    }\n    close(c)\n}\n\nfunc main() {\n    c := make(chan int, 10)\n    go fibonacci(cap(c), c)\n    for i := range c {\n        fmt.Println(i)\n    }\n}\n`}</code></pre>\n    <p>{`This prints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"select\"\n    }}>{`Select`}</h2>\n    <p>{`The select statement lets a goroutine wait on multiple communication operations.`}</p>\n    <p>{`A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc fibonacci(c, quit chan int) {\n    x, y := 0, 1\n    for {\n        select {\n        case c <- x:\n            x, y = y, x+y\n        case <-quit:\n            fmt.Println(\"quit\")\n            return\n        }\n    }\n}\n\nfunc main() {\n    c := make(chan int)\n    quit := make(chan int)\n    go func() {\n        for i := 0; i < 10; i++ {\n            fmt.Println(<-c)\n        }\n        quit <- 0\n    }()\n    fibonacci(c, quit)\n}\n`}</code></pre>\n    <p>{`After looping through in the IIFE `}<inlineCode parentName=\"p\">{`go func`}</inlineCode>{`, it will send a 0 to the `}<inlineCode parentName=\"p\">{`quit`}</inlineCode>{` channel and `}<inlineCode parentName=\"p\">{`select`}</inlineCode>{` will handle by printing \"quit\" and returning from the infinite `}<inlineCode parentName=\"p\">{`for`}</inlineCode>{` loop.`}</p>\n    <h2 {...{\n      \"id\": \"default-selection\"\n    }}>{`Default Selection`}</h2>\n    <p>{`The default case in a select is run if no other case is ready.`}</p>\n    <p>{`Use a default case to try a send or receive without blocking:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`select {\ncase i := <-c:\n    // use i\ndefault:\n    // receiving from c would block\n}\n`}</code></pre>\n    <p>{`Example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    tick := time.Tick(100 * time.Millisecond)\n    boom := time.After(500 * time.Millisecond)\n    for {\n        select {\n        case <-tick:\n            fmt.Println(\"tick.\")\n        case <-boom:\n            fmt.Println(\"BOOM!\")\n            return\n        default:\n            fmt.Println(\"    .\")\n            time.Sleep(50 * time.Millisecond)\n        }\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"example-equivalent-binary-trees\"\n    }}>{`Example: Equivalent Binary Trees`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n  \"golang.org/x/tour/tree\"\n  \"fmt\"\n)\n\n// Walk walks the tree t sending all values\n// from the tree to the channel ch.\nfunc Walk(t *tree.Tree, ch chan int) {\n    defer close(ch) // <- closes the channel when this function returns\n  var walk func(t *tree.Tree)\n  walk = func(t *tree.Tree) {\n      if t == nil {\n          return\n      }\n      walk(t.Left)\n      ch <- t.Value\n      walk(t.Right)\n  }\n  walk(t)\n}\n\n// Same determines whether the trees\n// t1 and t2 contain the same values.\nfunc Same(t1, t2 *tree.Tree) bool {\n    done := make (chan bool)\n    defer close(done)\n\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n    go Walk(t1, ch1)\n    go Walk(t2, ch2)\n\n    go func() {\n        for i := range ch1 {\n            j := <-ch2\n            fmt.Println(\"i: %v\", i)\n            fmt.Println(\"j: %v\", j)\n\n            if i != j {\n                done <- false\n            }\n        }\n        done <- true\n    }()\n    return <-done\n}\n\nfunc main() {\n    ch := make(chan int)\n    go Walk(tree.New(1), ch)\n\n    for i := 1; i <= 10; i++ {\n        fmt.Println(<-ch)\n    }\n\n    t1 := tree.New(1)\n    t2 := tree.New(2)\n\n    res1 := Same(t1, t1)\n    fmt.Println(\"Res 1: %v\", res1)\n\n    res2 := Same(t1, t2)\n    fmt.Println(\"Res 2: %v\", res2)\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}