{"version":3,"sources":["webpack:///../manual/Go/Go-Methods-And-Pointers.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"ofAMO,IAAMA,EAAe,Q,sNAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,wCADR,yCAGA,iDACA,uBAAK,sBAAMC,WAAW,OAAU,CAC5B,UAAa,oBADZ,6ZAgCL,0IACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,+EAML,oIACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,kEAOL,0CAAyB,0BAAYA,WAAW,KAAvB,cAAzB,sKAAsP,0BAAYA,WAAW,KAAvB,cAAtP,OAAoT,0BAAYA,WAAW,KAAvB,iBAApT,mDACA,iBAAQ,CACN,GAAM,qBADR,qBAGA,+EACA,iDACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,ybA+BL,sGACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,+FAML,kIACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,oFAOL,sDAAqC,0BAAYA,WAAW,KAAvB,WAArC,sBAA+G,0BAAYA,WAAW,KAAvB,gBAA/G,KACA,iBAAQ,CACN,GAAM,wCADR,wCAGA,yEACA,6CAA4B,sBAAQA,WAAW,KAAnB,+DAA5B,KACA,sCAAqB,sBAAQA,WAAW,KAAnB,kDAArB,gFACA,8CAA6B,0BAAYA,WAAW,KAAvB,SAA7B,QAAuF,0BAAYA,WAAW,KAAvB,OAAvF,2BAAkK,0BAAYA,WAAW,KAAvB,WAAlK,6DACA,oL,6MAKJJ,EAAWK,gBAAiB","file":"component---manual-go-go-methods-and-pointers-md-05d8bcf7939182234262.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"go-tour-methods--pointer-indirection\"\n    }}>{`Go Tour Methods & Pointer Indirection`}</h1>\n    <p>{`Take the following code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n\nfunc ScaleFunc(v *Vertex, f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n\nfunc main() {\n    v := Vertex{3, 4}\n    v.Scale(2)\n    ScaleFunc(&v, 10)\n\n    p := &Vertex{4, 3}\n    p.Scale(3)\n    ScaleFunc(p, 8)\n\n    fmt.Println(v, p)\n}\n`}</code></pre>\n    <p>{`Comparing the previous two programs, you might notice that functions with a pointer argument must take a pointer:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`var v Vertex\nScaleFunc(v, 5)  // Compile error!\nScaleFunc(&v, 5) // OK\n`}</code></pre>\n    <p>{`While methods with pointer receivers take either a value or a pointer as the receiver when they are called:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`var v Vertex\nv.Scale(5)  // OK\np := &v\np.Scale(10) // OK\n`}</code></pre>\n    <p>{`For the statement `}<inlineCode parentName=\"p\">{`v.Scale(5)`}</inlineCode>{`, even though v is a value and not a pointer, the method with the pointer receiver is called automatically. That is, as a convenience, Go interprets the statement `}<inlineCode parentName=\"p\">{`v.Scale(5)`}</inlineCode>{` as `}<inlineCode parentName=\"p\">{`(&v).Scale(5)`}</inlineCode>{` since the Scale method has a pointer receiver.`}</p>\n    <h2 {...{\n      \"id\": \"reverse-direction\"\n    }}>{`Reverse direction`}</h2>\n    <p>{`The equivalent thing happens in the reverse direction.`}</p>\n    <p>{`Take the following code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc AbsFunc(v Vertex) float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n    v := Vertex{3, 4}\n    fmt.Println(v.Abs())\n    fmt.Println(AbsFunc(v))\n\n    p := &Vertex{4, 3}\n    fmt.Println(p.Abs())\n    fmt.Println(AbsFunc(*p))\n}\n`}</code></pre>\n    <p>{`Functions that take a value argument must take a value of that specific type:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`var v Vertex\nfmt.Println(AbsFunc(v))  // OK\nfmt.Println(AbsFunc(&v)) // Compile error!\n`}</code></pre>\n    <p>{`While methods with value receivers take either a value or a pointer as the receiver when they are called:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`var v Vertex\nfmt.Println(v.Abs()) // OK\np := &v\nfmt.Println(p.Abs()) // OK\n`}</code></pre>\n    <p>{`In this case, the method call `}<inlineCode parentName=\"p\">{`p.Abs()`}</inlineCode>{` is interpreted as `}<inlineCode parentName=\"p\">{`(\\\\*p).Abs()`}</inlineCode>{`.`}</p>\n    <h1 {...{\n      \"id\": \"choosing-a-value-or-pointer-receiver\"\n    }}>{`Choosing a value or pointer receiver`}</h1>\n    <p>{`There are two reasons to use a pointer receiver.`}</p>\n    <p>{`The first is so that `}<strong parentName=\"p\">{`the method can modify the value that its receiver points to`}</strong>{`.`}</p>\n    <p>{`The second is `}<strong parentName=\"p\">{`to avoid copying the value on each method call`}</strong>{`. This can be more efficient if the receiver is a large struct, for example.`}</p>\n    <p>{`In this example, both `}<inlineCode parentName=\"p\">{`Scale`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Abs`}</inlineCode>{` are with receiver type `}<inlineCode parentName=\"p\">{`*Vertex`}</inlineCode>{`, even though the Abs method needn't modify its receiver.`}</p>\n    <p>{`In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both. (We'll see why over the next few pages.)`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}