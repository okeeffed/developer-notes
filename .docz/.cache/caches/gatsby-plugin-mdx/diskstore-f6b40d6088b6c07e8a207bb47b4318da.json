{"expireTime":9007200838659245000,"key":"gatsby-plugin-mdx-entire-payload-8f00c06a5b3392b6d37b94e87eafcc89-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Go Tour Methods & Pointer Indirection","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":40,"offset":206},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":40,"offset":206},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Take the following code:","position":{"start":{"line":10,"column":1,"offset":208},"end":{"line":10,"column":25,"offset":232},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":208},"end":{"line":10,"column":25,"offset":232},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc ScaleFunc(v *Vertex, f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(2)\n\tScaleFunc(&v, 10)\n\n\tp := &Vertex{4, 3}\n\tp.Scale(3)\n\tScaleFunc(p, 8)\n\n\tfmt.Println(v, p)\n}","position":{"start":{"line":12,"column":1,"offset":234},"end":{"line":42,"column":4,"offset":590},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Comparing the previous two programs, you might notice that functions with a pointer argument must take a pointer:","position":{"start":{"line":44,"column":1,"offset":592},"end":{"line":44,"column":114,"offset":705},"indent":[]}}],"position":{"start":{"line":44,"column":1,"offset":592},"end":{"line":44,"column":114,"offset":705},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"var v Vertex\nScaleFunc(v, 5)  // Compile error!\nScaleFunc(&v, 5) // OK","position":{"start":{"line":46,"column":1,"offset":707},"end":{"line":50,"column":4,"offset":791},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"While methods with pointer receivers take either a value or a pointer as the receiver when they are called:","position":{"start":{"line":52,"column":1,"offset":793},"end":{"line":52,"column":108,"offset":900},"indent":[]}}],"position":{"start":{"line":52,"column":1,"offset":793},"end":{"line":52,"column":108,"offset":900},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"var v Vertex\nv.Scale(5)  // OK\np := &v\np.Scale(10) // OK","position":{"start":{"line":54,"column":1,"offset":902},"end":{"line":59,"column":4,"offset":972},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"For the statement ","position":{"start":{"line":61,"column":1,"offset":974},"end":{"line":61,"column":19,"offset":992},"indent":[]}},{"type":"inlineCode","value":"v.Scale(5)","position":{"start":{"line":61,"column":19,"offset":992},"end":{"line":61,"column":31,"offset":1004},"indent":[]}},{"type":"text","value":", even though v is a value and not a pointer, the method with the pointer receiver is called automatically. That is, as a convenience, Go interprets the statement ","position":{"start":{"line":61,"column":31,"offset":1004},"end":{"line":61,"column":194,"offset":1167},"indent":[]}},{"type":"inlineCode","value":"v.Scale(5)","position":{"start":{"line":61,"column":194,"offset":1167},"end":{"line":61,"column":206,"offset":1179},"indent":[]}},{"type":"text","value":" as ","position":{"start":{"line":61,"column":206,"offset":1179},"end":{"line":61,"column":210,"offset":1183},"indent":[]}},{"type":"inlineCode","value":"(&v).Scale(5)","position":{"start":{"line":61,"column":210,"offset":1183},"end":{"line":61,"column":225,"offset":1198},"indent":[]}},{"type":"text","value":" since the Scale method has a pointer receiver.","position":{"start":{"line":61,"column":225,"offset":1198},"end":{"line":61,"column":272,"offset":1245},"indent":[]}}],"position":{"start":{"line":61,"column":1,"offset":974},"end":{"line":61,"column":272,"offset":1245},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Reverse direction","position":{"start":{"line":63,"column":4,"offset":1250},"end":{"line":63,"column":21,"offset":1267},"indent":[]}}],"position":{"start":{"line":63,"column":1,"offset":1247},"end":{"line":63,"column":21,"offset":1267},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The equivalent thing happens in the reverse direction.","position":{"start":{"line":65,"column":1,"offset":1269},"end":{"line":65,"column":55,"offset":1323},"indent":[]}}],"position":{"start":{"line":65,"column":1,"offset":1269},"end":{"line":65,"column":55,"offset":1323},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Take the following code:","position":{"start":{"line":67,"column":1,"offset":1325},"end":{"line":67,"column":25,"offset":1349},"indent":[]}}],"position":{"start":{"line":67,"column":1,"offset":1325},"end":{"line":67,"column":25,"offset":1349},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc AbsFunc(v Vertex) float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n\tfmt.Println(AbsFunc(v))\n\n\tp := &Vertex{4, 3}\n\tfmt.Println(p.Abs())\n\tfmt.Println(AbsFunc(*p))\n}","position":{"start":{"line":69,"column":1,"offset":1351},"end":{"line":98,"column":4,"offset":1739},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Functions that take a value argument must take a value of that specific type:","position":{"start":{"line":100,"column":1,"offset":1741},"end":{"line":100,"column":78,"offset":1818},"indent":[]}}],"position":{"start":{"line":100,"column":1,"offset":1741},"end":{"line":100,"column":78,"offset":1818},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"var v Vertex\nfmt.Println(AbsFunc(v))  // OK\nfmt.Println(AbsFunc(&v)) // Compile error!","position":{"start":{"line":102,"column":1,"offset":1820},"end":{"line":106,"column":4,"offset":1920},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"While methods with value receivers take either a value or a pointer as the receiver when they are called:","position":{"start":{"line":108,"column":1,"offset":1922},"end":{"line":108,"column":106,"offset":2027},"indent":[]}}],"position":{"start":{"line":108,"column":1,"offset":1922},"end":{"line":108,"column":106,"offset":2027},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"var v Vertex\nfmt.Println(v.Abs()) // OK\np := &v\nfmt.Println(p.Abs()) // OK","position":{"start":{"line":110,"column":1,"offset":2029},"end":{"line":115,"column":4,"offset":2117},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"In this case, the method call ","position":{"start":{"line":117,"column":1,"offset":2119},"end":{"line":117,"column":31,"offset":2149},"indent":[]}},{"type":"inlineCode","value":"p.Abs()","position":{"start":{"line":117,"column":31,"offset":2149},"end":{"line":117,"column":40,"offset":2158},"indent":[]}},{"type":"text","value":" is interpreted as ","position":{"start":{"line":117,"column":40,"offset":2158},"end":{"line":117,"column":59,"offset":2177},"indent":[]}},{"type":"inlineCode","value":"(\\*p).Abs()","position":{"start":{"line":117,"column":59,"offset":2177},"end":{"line":117,"column":72,"offset":2190},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":117,"column":72,"offset":2190},"end":{"line":117,"column":73,"offset":2191},"indent":[]}}],"position":{"start":{"line":117,"column":1,"offset":2119},"end":{"line":117,"column":73,"offset":2191},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Choosing a value or pointer receiver","position":{"start":{"line":119,"column":3,"offset":2195},"end":{"line":119,"column":39,"offset":2231},"indent":[]}}],"position":{"start":{"line":119,"column":1,"offset":2193},"end":{"line":119,"column":39,"offset":2231},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There are two reasons to use a pointer receiver.","position":{"start":{"line":121,"column":1,"offset":2233},"end":{"line":121,"column":49,"offset":2281},"indent":[]}}],"position":{"start":{"line":121,"column":1,"offset":2233},"end":{"line":121,"column":49,"offset":2281},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The first is so that ","position":{"start":{"line":123,"column":1,"offset":2283},"end":{"line":123,"column":22,"offset":2304},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"the method can modify the value that its receiver points to","position":{"start":{"line":123,"column":24,"offset":2306},"end":{"line":123,"column":83,"offset":2365},"indent":[]}}],"position":{"start":{"line":123,"column":22,"offset":2304},"end":{"line":123,"column":85,"offset":2367},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":123,"column":85,"offset":2367},"end":{"line":123,"column":86,"offset":2368},"indent":[]}}],"position":{"start":{"line":123,"column":1,"offset":2283},"end":{"line":123,"column":86,"offset":2368},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The second is ","position":{"start":{"line":125,"column":1,"offset":2370},"end":{"line":125,"column":15,"offset":2384},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"to avoid copying the value on each method call","position":{"start":{"line":125,"column":17,"offset":2386},"end":{"line":125,"column":63,"offset":2432},"indent":[]}}],"position":{"start":{"line":125,"column":15,"offset":2384},"end":{"line":125,"column":65,"offset":2434},"indent":[]}},{"type":"text","value":". This can be more efficient if the receiver is a large struct, for example.","position":{"start":{"line":125,"column":65,"offset":2434},"end":{"line":125,"column":141,"offset":2510},"indent":[]}}],"position":{"start":{"line":125,"column":1,"offset":2370},"end":{"line":125,"column":141,"offset":2510},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In this example, both ","position":{"start":{"line":127,"column":1,"offset":2512},"end":{"line":127,"column":23,"offset":2534},"indent":[]}},{"type":"inlineCode","value":"Scale","position":{"start":{"line":127,"column":23,"offset":2534},"end":{"line":127,"column":30,"offset":2541},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":127,"column":30,"offset":2541},"end":{"line":127,"column":35,"offset":2546},"indent":[]}},{"type":"inlineCode","value":"Abs","position":{"start":{"line":127,"column":35,"offset":2546},"end":{"line":127,"column":40,"offset":2551},"indent":[]}},{"type":"text","value":" are with receiver type ","position":{"start":{"line":127,"column":40,"offset":2551},"end":{"line":127,"column":64,"offset":2575},"indent":[]}},{"type":"inlineCode","value":"*Vertex","position":{"start":{"line":127,"column":64,"offset":2575},"end":{"line":127,"column":73,"offset":2584},"indent":[]}},{"type":"text","value":", even though the Abs method needn't modify its receiver.","position":{"start":{"line":127,"column":73,"offset":2584},"end":{"line":127,"column":130,"offset":2641},"indent":[]}}],"position":{"start":{"line":127,"column":1,"offset":2512},"end":{"line":127,"column":130,"offset":2641},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both. (We'll see why over the next few pages.)","position":{"start":{"line":129,"column":1,"offset":2643},"end":{"line":129,"column":155,"offset":2797},"indent":[]}}],"position":{"start":{"line":129,"column":1,"offset":2643},"end":{"line":129,"column":155,"offset":2797},"indent":[]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":132,"column":1,"offset":2800},"end":{"line":132,"column":31,"offset":2830},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":132,"column":31,"offset":2830}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"go-tour-methods--pointer-indirection\"\n    }}>{`Go Tour Methods & Pointer Indirection`}</h1>\n    <p>{`Take the following code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n\nfunc ScaleFunc(v *Vertex, f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n\nfunc main() {\n    v := Vertex{3, 4}\n    v.Scale(2)\n    ScaleFunc(&v, 10)\n\n    p := &Vertex{4, 3}\n    p.Scale(3)\n    ScaleFunc(p, 8)\n\n    fmt.Println(v, p)\n}\n`}</code></pre>\n    <p>{`Comparing the previous two programs, you might notice that functions with a pointer argument must take a pointer:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`var v Vertex\nScaleFunc(v, 5)  // Compile error!\nScaleFunc(&v, 5) // OK\n`}</code></pre>\n    <p>{`While methods with pointer receivers take either a value or a pointer as the receiver when they are called:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`var v Vertex\nv.Scale(5)  // OK\np := &v\np.Scale(10) // OK\n`}</code></pre>\n    <p>{`For the statement `}<inlineCode parentName=\"p\">{`v.Scale(5)`}</inlineCode>{`, even though v is a value and not a pointer, the method with the pointer receiver is called automatically. That is, as a convenience, Go interprets the statement `}<inlineCode parentName=\"p\">{`v.Scale(5)`}</inlineCode>{` as `}<inlineCode parentName=\"p\">{`(&v).Scale(5)`}</inlineCode>{` since the Scale method has a pointer receiver.`}</p>\n    <h2 {...{\n      \"id\": \"reverse-direction\"\n    }}>{`Reverse direction`}</h2>\n    <p>{`The equivalent thing happens in the reverse direction.`}</p>\n    <p>{`Take the following code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc AbsFunc(v Vertex) float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n    v := Vertex{3, 4}\n    fmt.Println(v.Abs())\n    fmt.Println(AbsFunc(v))\n\n    p := &Vertex{4, 3}\n    fmt.Println(p.Abs())\n    fmt.Println(AbsFunc(*p))\n}\n`}</code></pre>\n    <p>{`Functions that take a value argument must take a value of that specific type:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`var v Vertex\nfmt.Println(AbsFunc(v))  // OK\nfmt.Println(AbsFunc(&v)) // Compile error!\n`}</code></pre>\n    <p>{`While methods with value receivers take either a value or a pointer as the receiver when they are called:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`var v Vertex\nfmt.Println(v.Abs()) // OK\np := &v\nfmt.Println(p.Abs()) // OK\n`}</code></pre>\n    <p>{`In this case, the method call `}<inlineCode parentName=\"p\">{`p.Abs()`}</inlineCode>{` is interpreted as `}<inlineCode parentName=\"p\">{`(\\\\*p).Abs()`}</inlineCode>{`.`}</p>\n    <h1 {...{\n      \"id\": \"choosing-a-value-or-pointer-receiver\"\n    }}>{`Choosing a value or pointer receiver`}</h1>\n    <p>{`There are two reasons to use a pointer receiver.`}</p>\n    <p>{`The first is so that `}<strong parentName=\"p\">{`the method can modify the value that its receiver points to`}</strong>{`.`}</p>\n    <p>{`The second is `}<strong parentName=\"p\">{`to avoid copying the value on each method call`}</strong>{`. This can be more efficient if the receiver is a large struct, for example.`}</p>\n    <p>{`In this example, both `}<inlineCode parentName=\"p\">{`Scale`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Abs`}</inlineCode>{` are with receiver type `}<inlineCode parentName=\"p\">{`*Vertex`}</inlineCode>{`, even though the Abs method needn't modify its receiver.`}</p>\n    <p>{`In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both. (We'll see why over the next few pages.)`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}