(window.webpackJsonp=window.webpackJsonp||[]).push([[309],{fKgy:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return c})),t.d(n,"default",(function(){return u}));t("1c7q"),t("abGl"),t("gZHo"),t("Fdmb"),t("Ir+3"),t("2mQt"),t("mXGw");var a=t("/FXl"),r=t("TjRS"),i=(t("HZsF"),t("QxB1"));t("aD51");function o(){return(o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var c={};void 0!==c&&c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"manual/JavaScript/Functional-Light-JavaScript-v3.md"}});var s={_frontmatter:c},l=r.a;function u(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,["components"]);return Object(a.b)(l,o({},s,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"functional-light-javascript-v3"},"Functional-Light JavaScript v3"),Object(a.b)("p",null,"The course is by Kyle Simpson - Getify. This course can be accompanied by the book ",Object(a.b)("inlineCode",{parentName:"p"},"Functional-Light JS")," by Kyle."),Object(a.b)("p",null,"It is light as it is not trying to delve too deep in the mathematics."),Object(a.b)("h2",{id:"resources"},"Resources"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",o({parentName:"li"},{href:"https://frontendmasters.com/courses/functional-javascript-v3/"}),"FE Masters Course Link")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",o({parentName:"li"},{href:"http://static.frontendmasters.com/resources/2019-05-06-functional-light-v3/functional-light-v3.pdf"}),"FE Course Slides")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",o({parentName:"li"},{href:"https://github.com/getify/Functional-Light-JS"}),"GitHub Book")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",o({parentName:"li"},{href:"https://www.amazon.com/Functional-Light-JavaScript-Pragmatic-Balanced-FP-ebook/dp/B0787DBFKH"}),"Amazon Book")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",o({parentName:"li"},{href:"https://leanpub.com/fljs"}),"LeanPub Book")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",o({parentName:"li"},{href:"https://en.wikipedia.org/wiki/Monad_(category_theory)"}),"Monad - Wikipedia")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",o({parentName:"li"},{href:"https://github.com/lodash/lodash/wiki/FP-Guide"}),"Lodash FP")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",o({parentName:"li"},{href:"https://github.com/hemanth/functional-programming-jargon"}),"Functional Programming Jargon"))),Object(a.b)("h2",{id:"introduction"},"Introduction"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Akin to a rock climber already being on the wall and yelling terms down to a newbie, functional programmng books and courses also constantly yell terms and words without context.")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},'"The curse of functional programming is that you can get so used to it that you cannot explain it."')),Object(a.b)("h2",{id:"why-functional-programming"},"Why Functional Programming?"),Object(a.b)("h3",{id:"imperative-vs-declarative"},"Imperative vs declarative."),Object(a.b)("p",null,'Imperative is non-functional, code that is focus on "how to do something". The future reader needs to "read the code" and "mentally execute it" to understand. It forces the reader to do something that they\'re not naturally gifted.'),Object(a.b)("p",null,"Declarative makes it obvious. It is the idea of simpling delaring what is happening to the code. Declarative programming itself can also be perspective. It's about shifting towards the simpler implementation."),Object(a.b)("h3",{id:"the-journey"},"The journey"),Object(a.b)("p",null,"Kyle speaks to his personal journey and understanding that functional programming will be something that he'll be working towards for months and years, if not decades."),Object(a.b)("h3",{id:"code-is-provable"},"Code is provable"),Object(a.b)("p",null,"While it looks very programming-eque, a lot of it is actually based on math."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Even if can't prove a mathemtical principle, we can still take advantage of it.")),Object(a.b)("p",null,"Functional programmers since to get a joy from going through the formal proof, but that isn't required."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},'"If I can reduce the surface area of what I need to focus on, it will make my code more effective."')),Object(a.b)("h3",{id:"course-overview"},"Course overview"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Functions"),Object(a.b)("li",{parentName:"ol"},"Closure"),Object(a.b)("li",{parentName:"ol"},"Composition"),Object(a.b)("li",{parentName:"ol"},"Immutability"),Object(a.b)("li",{parentName:"ol"},"Recursion"),Object(a.b)("li",{parentName:"ol"},"Lists/Data Structures"),Object(a.b)("li",{parentName:"ol"},"Async"),Object(a.b)("li",{parentName:"ol"},"FP Libraries")),Object(a.b)("h2",{id:"function-purity"},"Function Purity"),Object(a.b)("h3",{id:"functions-vs-procedures"},"Functions vs Procedures"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Functional programming is not all about the function keyword.")),Object(a.b)("p",null,"Are the following functions?"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// doesn't return outputs\nfunction addNumbers(x = 0, y = 0, z = 0, w = 0) {\n  var total = x * y + z * w;\n  console.log(total);\n}\n\n// calls another procedure, therefore is a procedure\nfunction extraNumbers(x = 2, ...args) {\n  return addNummners(x, 40, ...args);\n}\n\nextraNumbers(); // 42\nextraNumbers(3, 8, 11); // 62\n")),Object(a.b)("p",null,'Believe it or not, they are "procedures".'),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Just because it uses the ",Object(a.b)("inlineCode",{parentName:"p"},"function")," keyword doesn't make it a function.")),Object(a.b)("p",null,"A function not only needs to take some inputs and do something with it, but also needs to return some outputs."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Functions can only call other functions. As soon as they call procedures, they themselves are a procedure.")),Object(a.b)("h3",{id:"naming-semantics"},"Naming Semantics"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function tuple(x, y) {\n  return [x + 1, y - 1];\n}\n\nvar [a, b] = tuple(...[5, 10]);\n\na; // 6\nb; //9\n")),Object(a.b)("p",null,"The above code is not in the spirit of a function. It matters if there is an obvious relationship between the two. The goal is to create relationships between the two."),Object(a.b)(i.BlockMath,{math:"f(x) = 2x^2 + 3",mdxType:"BlockMath"}),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"A function is a relationship between the input and an output.")),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function shippingRate(size, weight, speed) {\n  return (size + 1) * weight * speed;\n}\n")),Object(a.b)("p",null,"The above gives a relationship. Is the a semantic relationship between what we put in and what we get out."),Object(a.b)("h3",{id:"side-effects"},"Side Effects"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"For there to be a function, we cannot have side effects.")),Object(a.b)("p",null,"Here is an example of side effects:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function shippingRate() {\n  rate = (size + 1) * weight * speed;\n}\n\nvar rate;\nvar size = 12;\nvar weight = 4;\nvar speed = 5;\nshippingRate();\nrate; // 57\n\nsize = 8;\nsze = 6;\nshippingRage();\nrate; //42\n")),Object(a.b)("p",null,"This above code is affecting something somewhere else in the program. Not only must there be a relationship between the inputs and outputs, but they also need to be direct."),Object(a.b)("p",null,"As soon as they are indirect (as they are above) then it is no longer a function."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},'In JavaScript, there is no such thing as a "function". There is such thing as a "function call". It is the function call that matters. We cannot say it is a function without looking at the function call.')),Object(a.b)("h3",{id:"listing-some-side-effects"},"Listing some Side Effects"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"I/O (console, files etc)"),Object(a.b)("li",{parentName:"ol"},"Database Storage"),Object(a.b)("li",{parentName:"ol"},"Network Calls"),Object(a.b)("li",{parentName:"ol"},"DOM"),Object(a.b)("li",{parentName:"ol"},"Timestamps"),Object(a.b)("li",{parentName:"ol"},"Random Numbers"),Object(a.b)("li",{parentName:"ol"},"CPU Heat"),Object(a.b)("li",{parentName:"ol"},"CPU Time Delay")),Object(a.b)("p",null,"The reality is, you can't cut all of these things."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},'We we say "no side effects" we really mean "minimise side effects.')),Object(a.b)("p",null,"Side effects take away the benefits of functional programming. If we are going to do them, we need to be very intentional about them."),Object(a.b)("h2",{id:"pure-functions"},"Pure Functions"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Functions with a pure function call.")),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// pure\nfunction addTwo(x, y) {\n  return x + y;\n}\n\n// impure\n// z makes it impure as it is\n// an indirect variables\nfunction addAnother(x, y) {\n  return addTwo(x, y) + z;\n}\n")),Object(a.b)("p",null,'It is not just that we can\'t access variables from outside of itself, but this is a key "easy win".'),Object(a.b)("p",null,"In the following case, we can make the argument it is still functional:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"const x = 1;\n\n// pure\nfunction addTwo(x, y) {\n  return x + y;\n}\n\n// impure\n// z makes it impure as it is\n// an indirect variables\nfunction addAnother(x, y) {\n  return addTwo(x, y) + z;\n}\n\naddAnother(20, 21); // 42\n")),Object(a.b)("p",null,"Because we can see all the code and that it is not re-assigned, we can declare that it is functional due to our understanding of the applicatons given the immutability."),Object(a.b)("p",null,"Note that ",Object(a.b)("inlineCode",{parentName:"p"},"addTwo")," could always be re-assigned as well - this is an important case to make when arguing that ",Object(a.b)("inlineCode",{parentName:"p"},"addAnother")," is still functional."),Object(a.b)("p",null,"There is an onus on us as coders to make it obvious that these things are constant."),Object(a.b)("h3",{id:"reducing-surface-area"},"Reducing Surface Area"),Object(a.b)("p",null,"By reducing surface area, we can improve the readability of our code."),Object(a.b)("p",null,"This is a partial application (aka currying)."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function addAnother(z) {\n  return function addTwo(x, y) {\n    return x + y + z;\n  };\n}\n\naddAnother(1)(20, 21);\n")),Object(a.b)("h3",{id:"same-input-same-output"},"Same Input, Same Output"),Object(a.b)("p",null,"If we were to call ",Object(a.b)("inlineCode",{parentName:"p"},"getId")," over and over again with the same object, how sure are at its predicatability?"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function getId(obj) {\n  return obj.id;\n}\n")),Object(a.b)("p",null,"Let's say we reveal more of the program."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"getId({\n  get id() {\n    return Math.random();\n  },\n});\n")),Object(a.b)("p",null,"Now that we've seen more of the code, we reduce our confidence given the getter uses a side effect."),Object(a.b)("p",null,'The aim is to get to "same input, same output".'),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Functional purity is a level of confidence, not a binary characteristic.")),Object(a.b)("p",null,"The point of functional programming in JS is about our level of confidence in behaving pure."),Object(a.b)("h2",{id:"extracting-impurity"},"Extracting Impurity"),Object(a.b)("p",null,"The key technique is to extract our the impurity. It doesn't remove that impure functionality, but to extract our the impurity and leave a pure function."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// impure\nfunction addComment(comment) {\n  return {\n    id: randomId()\n    comment: comment\n  }\n}\nconst comment = addComment('Hello')\n\n// now pure\nfunction addComment(id, comment) {\n  return {\n    id: id\n    comment: comment\n  }\n}\n\nconst id = randomId()\nconst comment = addComment(id, 'Hello')\n")),Object(a.b)("p",null,"The alternative is the contain impurity by reducing the surface area."),Object(a.b)("p",null,"We have two methods explained to do this:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Create a Wrapper"),Object(a.b)("li",{parentName:"ol"},"Create an Adapter")),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// convert from this...\nvar SomeAPI = {\n  threshold: 13,\n  isBelowThreshold(x) {\n    return x <= SomeAPI.threshold;\n  },\n};\nvar numbers = [];\n\nfunction insertSortedDesc(v) {\n  SomeAPI.threshold = v;\n  var idx = numbers.findIndex(SomeAPI.isBelowThreshold);\n  if (idx == -1) {\n    idx = numbers.length;\n  }\n  numbers.splice(idx, 0, v);\n}\n\ninsertSortedDesc(3);\ninsertSortedDesc(5);\ninsertSortedDesc(1);\ninsertSortedDesc(4);\ninsertSortedDesc(2);\nnumbers; // [5,4,3,2,1]\n\n// ...to this...\n// approach a (creating a Wrapper)\nvar SomeAPI = {\n  threshold: 13,\n  isBelowThreshold(x) {\n    return x <= SomeAPI.threshold;\n  },\n};\nvar numbers = [];\n\nfunction getSortedNums(nums, v) {\n  // create side effect on local nums\n  var numbers = nums.slice();\n  insertSortedDesc(v);\n  return numbers;\n\n  function insertSortedDesc(v) {\n    SomeAPI.threshold = v;\n    var idx = numbers.findIndex(SomeAPI.isBelowThreshold);\n    if (idx == -1) {\n      idx = numbers.length;\n    }\n    numbers.splice(idx, 0, v);\n  }\n}\n\nnumbers = getSortedNums(numbers, 3);\nnumbers = getSortedNums(numbers, 5);\nnumbers = getSortedNums(numbers, 4);\nnumbers = getSortedNums(numbers, 1);\nnumbers = getSortedNums(numbers, 2);\nnumbers; // [5,4,3,2,1]\n\n// ...or to this\n// approach b (creating an Adapter function)\nvar SomeAPI = {\n  threshold: 13,\n  isBelowThreshold(x) {\n    return x <= SomeAPI.threshold;\n  },\n};\nvar numbers = [];\n\nfunction insertSortedDesc(v) {\n  SomeAPI.threshold = v;\n  var idx = numbers.findIndex(SomeAPI.isBelowThreshold);\n  if (idx == -1) {\n    idx = numbers.length;\n  }\n  numbers.splice(idx, 0, v);\n}\n\n// copy, then modify by side effects\n// then return to orig state\nfunction getSortedNums(nums, v) {\n  var [origNumbers, origThreshold] = [numbers, SomeAPI.threshold];\n  numbers = nums.slice();\n  insertSortedDesc(v);\n  nums = numbers;\n  [numbers, SomeAPI.threshold] = [origNumbers, origThreshold];\n  return nums;\n}\n\nnumbers = getSortedNums(numbers, 3);\nnumbers = getSortedNums(numbers, 5);\nnumbers = getSortedNums(numbers, 4);\nnumbers = getSortedNums(numbers, 1);\nnumbers = getSortedNums(numbers, 2);\nnumbers; // [5,4,3,2,1]\n")),Object(a.b)("h2",{id:"argument-adapters"},"Argument Adapters"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Parameters and arguments refer to different things. Parameter is the number of the argument, while argument is the value.")),Object(a.b)("p",null,'The "shape of the function" can have some names ie unary, binary etc.'),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// unary\nfunction increment(x) {\n  return sum(x, 1);\n}\n\n// binary\nfunction sum(x, y) {\n  return x * y;\n}\n")),Object(a.b)("p",null,"HOF: Higher order function receives or returns one or more functions."),Object(a.b)("p",null,"Taking a unary function to become a binary:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function unary(fn) {\n  return function one(arg) {\n    return fn(arg);\n  };\n}\n\nfunction binary(fn) {\n  return function two(arg1, arg2) {\n    return fn(arg1, arg2);\n  };\n}\n\nfunction f(...args) {\n  return args;\n}\n\nvar g = unary(f);\nvar h = binary(f);\n\ng(1, 2, 3, 4); // [1]\nh(1, 2, 3, 4); // [1,2]\n")),Object(a.b)("p",null,"It is critical here to know that we can take an function and adapt its shape."),Object(a.b)("p",null,"If you knows things do not fit, you need to be able to see how we can adapt a function to make it work the way we need. HOFs are key to functional programming."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"In functional programming, we want to fit in the lego pieces that apply to what we want. We should use the standard naming and utilities that are available.")),Object(a.b)("h3",{id:"spread-adapter"},"Spread adapter"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"g")," is the ",Object(a.b)("inlineCode",{parentName:"p"},"apply")," of ",Object(a.b)("inlineCode",{parentName:"p"},"f"),":"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function spreadArgs(fn) {\n  return function spread(args) {\n    return fn(...args)\n  }\n}\n\nfunction f(a,b,c,d) {\n  return a + b + c +d\n}\n\nfunction g = spreadArgs(f)\n\nf([1,2,3,4]);\n")),Object(a.b)("h2",{id:"point-free"},"Point-Free"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"It is a style of defining a function without writing a function. We want to define a function without having to define its inputs.")),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// person it the input point for the\n// renderPerson function\ngetPerson(function onPerson(person) {\n  return renderPerson(person);\n});\n\n// Since they have the same shape, we\n// can just pass in the function.\n// This is called equational reasoning.\n// Now we haven't had to list the point.\ngetPerson(renderPerson);\n")),Object(a.b)("p",null,"Equational reasoning is when two functions have equivalent function shapes."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"If the code is not more readable and beneficial, then don't use point free and equational reasoning.")),Object(a.b)("p",null,"An example of a point free refactor:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function isOdd(v) {\n  return v % 2 == 1;\n}\n\nfunction isEven(v) {\n  return !isOdd(v);\n}\n\nisEven(4); // true\n")),Object(a.b)("p",null,"Know that is functional programming, sometimes it is better to be a little repetitive. We are explicit here in the relationship between ",Object(a.b)("inlineCode",{parentName:"p"},"isOdd")," and ",Object(a.b)("inlineCode",{parentName:"p"},"isEven"),"."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"When we have points, we have a explicit, imperative way of programming but we are moving towards the declarative code as it is more implicit.")),Object(a.b)("p",null,"We do this by adapter the shape of a fucntion."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// sometimes called complement in FP\nfunction not(fn) {\n  return function negated(...args) {\n    return !fn(...args)\n  }\n}\nfunction isOdd(v) {\n  return v % 2 == 1;\n}\n\nfunction isEven(v) = not(isOdd)\n\nisEven(4); // true\n")),Object(a.b)("h3",{id:"advanced-point-free"},"Advanced Point-Free"),Object(a.b)("p",null,"Functional programmers care a lot about the shape of the fuctions. Not just the number of args, but also the order."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function mod(y) {\n  return function forX(x) {\n    return x % y;\n  };\n}\n\nfunction eq(y) {\n  return function forX(x) {\n    return x === y;\n  };\n}\n")),Object(a.b)("p",null,"We now use this to ",Object(a.b)("inlineCode",{parentName:"p"},"isOdd")," this way:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"var mod2 = mod(2);\nvar eq1 = eq(1);\n\n// this is moving a big way\n// from operators to functions\nfunction isOdd(x) {\n  return eq1(mod(x));\n}\n")),Object(a.b)("p",null,"From here, we have a more specialised function that we can compose to make point-free:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"var mod2 = mod(2);\nvar eq1 = eq(1);\n\n// this is moving a big way\n// from operators to functions\nfunction isOdd(x) {\n  return eq1(mod(x));\n}\n\n// compare this to isOdd using\n// equational reasoning\nfunction compose(fn2, fn1) {\n  return fucntion composed(v) {\n    return fn2(fn1(v))\n  }\n}\n\n// we can declare isOdd based on the\n// equational reasoning\nvar isOdd = compose(eq1,mod2)\n\n// final point-free definition\nvar isOdd = compose(eq(1), mod(2))\n")),Object(a.b)("h2",{id:"closure"},"Closure"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},'Definition: Closure is when a function "remembers" the variabels around it even when that function is executed elsewhere.')),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// example of closure\nfunction makeCounter() {\n  var counter = 0;\n  return function increment() {\n    return ++counter;\n  };\n}\n\nvar c = makeCounter();\n\nc(); // 1\nc(); // 2\nc(); // 3\n")),Object(a.b)("p",null,"Note that closure is not functionally pure, but it ca be used. The closure in the above example is impure because it doesn't return the same output."),Object(a.b)("p",null,"Here is one of the examples of closure that we saw:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function unary(fn) {\n  return function one(arg) {\n    return fn(arg);\n  };\n}\n")),Object(a.b)("h2",{id:"lazy-vs-eager-execution"},"Lazy vs Eager Execution"),Object(a.b)("p",null,"When to understand the idea of deferring when things are executing."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function repeater(count) {\n  return function allTheAs() {\n    return ''.padStart(count, 'A');\n  };\n}\n\nvar A = repeater(10);\nA(); // \"AAAAAAAAAA\"\nA(); // \"AAAAAAAAAA\"\n")),Object(a.b)("p",null,"This example is known as deferring/lazy we we defer the execution until ",Object(a.b)("inlineCode",{parentName:"p"},"A")," is called. By adding the extra layer for deferring, we can ensure execution happens later."),Object(a.b)("p",null,"What happens if the above is expensive work? Currently, ",Object(a.b)("inlineCode",{parentName:"p"},"A")," is being lazy and the expense always occurs. We can be ",Object(a.b)("inlineCode",{parentName:"p"},"eager")," to prevent all the work from happening:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function repeater(count) {\n  var str = ''.padStart(count, 'A');\n  return function allTheAs() {\n    return str;\n  };\n}\n\nvar A = repeater(10);\nA(); // \"AAAAAAAAAA\"\nA(); // \"AAAAAAAAAA\"\n")),Object(a.b)("p",null,"There are pros and cons to using ",Object(a.b)("inlineCode",{parentName:"p"},"lazy")," or ",Object(a.b)("inlineCode",{parentName:"p"},"eager")," closures. That is a trade off."),Object(a.b)("p",null,"How can we occur if the work had be done before and not do it again? We can use ",Object(a.b)("inlineCode",{parentName:"p"},"memoization"),":"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// We are closed over something that s\n// is changeing - this should give flags\n// that is could be impure.\n// The code itself is pure once we\n// look further into how the code is\n// used. It has a high degree of\n// confidence.\nfunction repeater(count) {\n  var str;\n  return function allTheAs() {\n    if (str == undefined) {\n      str = ''.padStart(count, 'A');\n    }\n\n    return str;\n  };\n}\n\nvar A = repeater(10);\nA(); // \"AAAAAAAAAA\"\nA(); // \"AAAAAAAAAA\"\n")),Object(a.b)("p",null,"How can we achieve this level of performance without shooting ourselves in the foot?"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// much more obviously pure\nfunction repeater(count) {\n  return memoize(function allTheAs() {\n    return ''.padStart(count, 'A');\n  });\n}\n\nvar A = repeater(10);\nA(); // \"AAAAAAAAAA\"\nA(); // \"AAAAAAAAAA\"\n")),Object(a.b)("p",null,"There is a cost for ",Object(a.b)("inlineCode",{parentName:"p"},"memoization")," - it will take up memory. You need to understand if the usage pattern says you would benefit from the performance."),Object(a.b)("h2",{id:"referential-transparency"},"Referential Transparency"),Object(a.b)("p",null,"Finally - we are ready to get the answer of what a pure function is. Here is the canonical definition:"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"If I can take the return value of that function call and replace the function call with the return. There is a special term for this, called ",Object(a.b)("inlineCode",{parentName:"p"},"referential transparency"),".")),Object(a.b)("p",null,"Referential transparency is key in Haskell given the guarentee of the language."),Object(a.b)("p",null,'The "real" benefit of referential transparency is the readability to the user.'),Object(a.b)("h3",{id:"generalised-to-specialised"},"Generalised to specialised"),Object(a.b)("p",null,"This is concept of taking a generalised function and creating a clearer relationship."),Object(a.b)("p",null,"Is there a way to define more specialised functions without creating clutter?"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Remember: Parameter Order is very important with the aim of going left with the most general to the most specific. The example used here is why the array is passed before the callback in ",Object(a.b)("inlineCode",{parentName:"p"},"map"),".")),Object(a.b)("h2",{id:"partial-applications--currying"},"Partial Applications & Currying"),Object(a.b)("p",null,"One way to go about specialisation is partial application."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Partial application is partially adding an argument of a functional a step at a time.")),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function ajax(url, data, cb) {\n  /* ... */\n}\n\nvar getCustomer = partial(ajax, CUSTOMER_API);\nvar getCurrentUser = partial(getCustomer, { id: 42 });\ngetCustomer({ id: 42 }, renderCustomer);\ngetCurrentUser(renderCustomer);\n")),Object(a.b)("p",null,"Currying is the more common form of specialisation."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),'function ajax(url, data, cb) {\n  return function getData(data) {\n    return function getCB(cb) {\n      /* ... */\n    };\n  };\n}\n\n// "manual currying" - calling the function\najax(CUSTOMER_API)({ id: 42 })(renderCustomer);\n\n// specialising\ngetCustomer = ajax(CUSTOMER_API);\ngetCurrentUser(renderCustomer);\n')),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"In Haskell, all functions are unary, and currying is the requirement.")),Object(a.b)("p",null,"We have a ",Object(a.b)("inlineCode",{parentName:"p"},"curry")," utility that can do all of this for us:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// takes how many arguments you expect to receieve\n// then the function\nvar ajax = curry(3, function ajax(url, data, cb) {\n  /* ... */\n});\n\n// specialising\ngetCustomer = ajax(CUSTOMER_API);\ngetCurrentUser(renderCustomer);\n")),Object(a.b)("h3",{id:"partial-application-vs-currying"},"Partial Application vs Currying"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Both are specialisation techniques."),Object(a.b)("li",{parentName:"ol"},"Partial Application presents some arguments now, receives the rest on the next call."),Object(a.b)("li",{parentName:"ol"},"Currying doesn't preset any arguments. Receives each argument on at a time.")),Object(a.b)("p",null,"There is a notion of strict vs loose currying. If you provide only one input at a time, that is know as ",Object(a.b)("inlineCode",{parentName:"p"},"strict currying"),". The ",Object(a.b)("inlineCode",{parentName:"p"},"loose currying")," is to provide multiple inputs in one call."),Object(a.b)("h3",{id:"changing-function-shape-with-currying"},"Changing function shape with currying"),Object(a.b)("p",null,"If we use currying, we can then be point free at how we're running."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function add(x, y) {\n  return x + y;\n}\n\n[0, 2, 4, 6, 8].map(function addOne(v) {\n  return add(1, v);\n});\n// [1,3,5,7,9]\n\n// adapting to become point free\nadd = curry(add);\n[(0, 2, 4, 6, 8)].map(add(1));\n// [1,3,5,7,9]\n")),Object(a.b)("h2",{id:"composition"},"Composition"),Object(a.b)("p",null,"The following code we're going to use to try illustrate the benefit of composition:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function minus2(x) {\n  return x - 2;\n}\nfunction triple(x) {\n  return x * 3;\n}\nfunction increment(x) {\n  return x + 1;\n}\n\n// add shipping rate\nvar tmp = increment(4);\ntmp = triple(tmp);\ntotalCost = basePrice + minus2(tmp);\n")),Object(a.b)("p",null,"Composition works from right-to-left. The analogy used is the machines that transform elements at differing parts of the conveyor belt journey."),Object(a.b)("p",null,"We abstract to create a separation of concerns."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function minus2(x) {\n  return x - 2;\n}\nfunction triple(x) {\n  return x * 3;\n}\nfunction increment(x) {\n  return x + 1;\n}\n\nfunction shippingRate(x) {\n  // composing the functions used for the rate\n  return minus2(triple(increment(x)));\n}\n\n// add shipping rate\ntotalCost = basePrice + shippingRate(4);\n")),Object(a.b)("h3",{id:"piping-vs-composition"},"Piping vs Composition"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function minus2(x) {\n  return x - 2;\n}\nfunction triple(x) {\n  return x * 3;\n}\nfunction increment(x) {\n  return x + 1;\n}\n\nvar f = compose(\n  minus2,\n  triple,\n  increment,\n);\nvar p = compose(\n  increment,\n  triple,\n  minus2,\n);\n\nf(4); // 13\np(4); // 7\n\nvar g = pipeThree(v);\ng(4); // 7\n")),Object(a.b)("h3",{id:"associaitivity"},"Associaitivity"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"1 + 2 + 3")," - the plus operator is associative, so doesn't matter the order that we put it in."),Object(a.b)("p",null,"The same is said with composition."),Object(a.b)("h3",{id:"composition-with-currying"},"Composition With Currying"),Object(a.b)("p",null,"Because functions generally give one return value, it is vastly more useful to curry and pass unary functions."),Object(a.b)("h2",{id:"immutabililty"},"Immutabililty"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"The idea that something doesn't change unexpectantly.")),Object(a.b)("p",null,"Assigment immutability: a variable that cannot be reassigned."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"var basePrice = 89.99;\nconst shippingCost = 6.5;\n")),Object(a.b)("p",null,"In JavaScript however, an array, functions and objects can be mutated (even with the ",Object(a.b)("inlineCode",{parentName:"p"},"const")," keyword). The ",Object(a.b)("inlineCode",{parentName:"p"},"const")," keyword just means the assignment is not going to change."),Object(a.b)("h3",{id:"value-immutability"},"Value immutability"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Kyle has mentioned that accidental reassignment is never an issue thats come up.")),Object(a.b)("p",null,"So we can use ",Object(a.b)("inlineCode",{parentName:"p"},"Object.freeze"),' to make a value "read-only". However, this will only make a fatal error.'),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"let orderDetails = {\n  orderId: 42,\n  total: basePrice + shipping,\n};\n\nif (orderedItems.length > 0) {\n  orderDetails.items = orderedItems;\n}\n\nprocessOrder(Object.freeze(orderDetails));\n")),Object(a.b)("h3",{id:"read-only-data-structures"},"Read-Only Data Structures"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Data structures that never need to be mutated.")),Object(a.b)("p",null,"Don't mutate, copy. You should ALWAYS assume that things are read-only and you cannot mutate it. We do this by making a copy of any object."),Object(a.b)("p",null,"In real life, we want to mitigate the cost of storing in memory, CPU, garbage collection etc. Immutable data structures in turn tend to store a diff of changes and point back to the original object."),Object(a.b)("h3",{id:"immutablejs"},"Immutable.js"),Object(a.b)("p",null,"This library is here in the interim (from Facebook). The other preferred library is ",Object(a.b)("inlineCode",{parentName:"p"},"Mori"),". Both have a similar endgoal."),Object(a.b)("p",null,"Both libraries handle the optimisation."),Object(a.b)("p",null,"The three things we should think about the the immutability:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Annotate with ",Object(a.b)("inlineCode",{parentName:"li"},"Object.freeze"),"."),Object(a.b)("li",{parentName:"ol"},"Assume any data structure received is read-only."),Object(a.b)("li",{parentName:"ol"},"If you need to track changes to data structures, that's what you should do with immutable data structures.")),Object(a.b)("h2",{id:"recursion"},"Recursion"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Not as complicated as it is made to be.")),Object(a.b)("p",null,"The example shows an iterative loop to go through a sentence. The issue that you have to read the for-loop and mentally execute it to understand what is going."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Recursion: reducing the problem set.")),Object(a.b)("p",null,"The idea is to make the problem set smaller and smaller. Ie, check the first element of the string, then the rest of the smaller string."),Object(a.b)("p",null,"Recursive definition:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Understand the base case."),Object(a.b)("li",{parentName:"ol"},"Handle the remaining pattern.")),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function countVowels(str) {\n  // base condition\n  if (str.length == 0) return 0;\n\n  var first = isVowel(str[0]) ? 1 : 0;\n  return first + countVowels(str.slice(1));\n}\n\ncountVowels('This is the sentence that we want to test');\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Recursion is designed to be a declarative approach.")),Object(a.b)("p",null,"There are some recursion patterns that are common:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Solve the subproblems"),Object(a.b)("li",{parentName:"ol"},"Divide and conquer")),Object(a.b)("p",null,"There are more to it, but it is worth noting."),Object(a.b)("h3",{id:"stack-frames-and-memory-limits"},"Stack Frames and Memory Limits"),Object(a.b)("p",null,"In the practical sense, recursion doesn't often get placed into production."),Object(a.b)("p",null,"The practical limitation can be understood by understanding memory."),Object(a.b)("p",null,"If you're in the middle of function A, but then call function B, you need to somehow store everything from function A. We call it a stack frame, because we have a stack that is growing from these recursive calls. In the stack frame we store local variables, program counter etc."),Object(a.b)("h3",{id:"optimisation-tail-calls"},"Optimisation: Tail Calls"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Tail call: we don't need the current stack frame, so dispatch to another call. Only holds for calls made in the tail position.")),Object(a.b)("p",null,"Tail calls may not necessarily run faster, but the memory usage is improved."),Object(a.b)("p",null,"JavaScript has had in place to not run so far to even run out of memory. There is a limit to how many function calls can be done in depth."),Object(a.b)("h3",{id:"proper-tails-calls"},"Proper Tails Calls"),Object(a.b)("p",null,"PTC are the idea that a tail call gets memory optimised. TCO (Tail Call Operations) are a family of optimisations that are optional for tail calls."),Object(a.b)("p",null,"PTC were standardised. It should be possible for an operation in a tail call position to be optimised. TC39 decided to let PTC in ES6."),Object(a.b)("p",null,"Proper tail calls require ",Object(a.b)("inlineCode",{parentName:"p"},"use strict")," keyword and ",Object(a.b)("inlineCode",{parentName:"p"},"return function")," at the end of a function."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"'use strict';\n\nvar countVowels = curry(2, function countVowels(count, str) {\n  var count = isVowel(str[0]) ? 1 : 0;\n  // base condition\n  if (str.length <= 1) return count;\n\n  return countVowels(count, str.slice(1));\n});\n\ncountVowels('Hello the world!');\n")),Object(a.b)("h2",{id:"continuation-passing-style"},"Continuation-Passing Style"),Object(a.b)("p",null,"It is worth noting this since we can't rely on Proper Tail Calls."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"'use strict';\n\nfunction countVowels(str, cont = v => v) {\n  var count = isVowel(str[0]) ? 1 : 0;\n  // base condition\n  if (str.length <= 1) return count;\n\n  return countVowels(str.slice(1), function f(v) {\n    return cont(first + v);\n  });\n}\n\ncountVowels('Hello the world!');\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Note: ",Object(a.b)("inlineCode",{parentName:"p"},"v => v")," is known as the identity function.")),Object(a.b)("p",null,"CPS is a cheat, since we are deferring the real recursive call. We aren't fixing the memory problem, but we are now storing the data on the heap instead of the stack."),Object(a.b)("h2",{id:"trampolines"},"Trampolines"),Object(a.b)("p",null,"A function call function, then return another one. We never want to build the stack depth beyond one."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function trampoline(fn) {\n  return function trampolined(...args) {\n    var results = fn(...args);\n\n    while (typeof result == 'function') {\n      result = result();\n    }\n\n    return result;\n  };\n}\n")),Object(a.b)("p",null,"So this is how it looks in practice:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"'use strict';\n\nvar countVowels = trampoline(function countVowels(count, str) {\n  var count = isVowel(str[0]) ? 1 : 0;\n  // base condition\n  if (str.length <= 1) return count;\n\n  return function f() {\n    return countVowels(count, str.slice(1));\n  };\n});\n\nconst countVowels = curry(2, countVowels)(0);\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"This is the current state that Kyle writes his recursion functions. Put it into tail call form and then wrap it in a trampoline.")),Object(a.b)("h2",{id:"list-operations"},"List Operations"),Object(a.b)("h3",{id:"map-transformations"},"Map: Transformations"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Functor is a value over which those values it in can be mapped.")),Object(a.b)("p",null,"Map will take a value and transform it. The map needs to create a new data structure."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function makeRecord(name) {\n  return { id: uniqID(), name };\n}\n\n['Kyle', 'Susan'].map(makeRecord);\n")),Object(a.b)("h3",{id:"filter-inclusion"},"Filter: Inclusion"),Object(a.b)("p",null,"Filter in programming is actually a filter in. We take a set of inputs and return only a filtered in set of outputs."),Object(a.b)("h3",{id:"reduce-combination"},"Reduce: Combination"),Object(a.b)("p",null,"Reduce is a very general operation."),Object(a.b)("p",null,"Note that you need to select an appropriate initial value."),Object(a.b)("h3",{id:"composition-with-reduce"},"Composition with Reduce"),Object(a.b)("p",null,"The example shows how to implement a ",Object(a.b)("inlineCode",{parentName:"p"},"pipe")," and ",Object(a.b)("inlineCode",{parentName:"p"},"compose")," function by using ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," and ",Object(a.b)("inlineCode",{parentName:"p"},"reduceRight"),"."),Object(a.b)("h2",{id:"fusion"},"Fusion"),Object(a.b)("p",null,"It will be extremely common to start chains."),Object(a.b)("p",null,"There is a downside for using these chains. One is performance. The intermidiate states for the items list that are large need to be garbage collect."),Object(a.b)("p",null,"The other is the state at any time."),Object(a.b)("h2",{id:"transduction"},"Transduction"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"The concept of composing together map, filter, reduce methods. This is due to all three functions having different shapes. Transducing is composition of reducers. We want to turn the maps and predicates into transducers.")),Object(a.b)("p",null,"There is an API by the name of ",Object(a.b)("inlineCode",{parentName:"p"},"transduce")," that allows us to use all this."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),'// not, it isn\'t the function calls themselves\n// but the arguments going into those functions\nfunction add1(v) {\n  return v + 1;\n}\nfunction isOdd(v) {\n  return v % 2 == 1;\n}\nfunction sum(total, v) {\n  return total + v;\n}\n\nvar list = [1, 2, 3, 4, 5];\n\n// Attempt 1: note that the returns and functions themselves have\n// incompatible shapes\nlist\n  .map(add1)\n  .filter(isOdd)\n  .reduce(sum); // 42\n\n// Attempt 2: note that this approach now is imperative\nlist.reduce(function allAtOnce(total, v) {\n  v = add1(v);\n  if (isOdd(v)) {\n    total = sum(total, v);\n  }\n  return total;\n}, 0); // 42\n\n// Attempt 3: we want to use tranducers\n// note: a transducer NEEDS a reducer\nvar transducer = compose(\n  // we pass our "maps" and "filters"\n  // to their reduce counterpart\n  mapReducer(add1),\n  filterReducer(isOdd),\n);\n\ntransduce(\n  // needs the transducer\n  transducer,\n  // needs the reduction function\n  sum,\n  // needs the inital value\n  0,\n  // needs to data to map over\n  list,\n);\n\n// Attempt 4: using the "into" helper function\n// into passes us something akin to the sum.\n// function. It knows based on transducer type.\n// "into" is just a shorthand.\ninto(transducer, 0, list);\n')),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Transducer is a higher-order reducer.")),Object(a.b)("h3",{id:"deriving-transduction"},"Deriving Transduction"),Object(a.b)("p",null,"From here, things will get difficult. Let's start again:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function add1(v) {\n  return v + 1;\n}\nfunction isOdd(v) {\n  return v % 2 == 1;\n}\nfunction sum(total, v) {\n  return total + v;\n}\n\nvar list = [1, 2, 3, 4, 5];\n\n// 1: Let's take this as our basis again\nlist\n  .map(add1)\n  .filter(isOdd)\n  .reduce(sum);\n\n// 2: Let's show what happens when we create our own reducers\nfunction mapWithReduce(arr, mappingFn) {\n  return arr.reduce(function reducer(list, v) {\n    // specifically cutting a corner\n    // it is using mutation\n    list.push(mappingFn(v));\n    return list;\n  }, []);\n}\n\nfunction filterWithReduce(arr, predicateFn) {\n  return arr.reduce(function reducer(list, v) {\n    if (predicateFn(v)) list.push(v);\n    return list;\n  }, []);\n}\n\nlist = mapWithReduce(list, add1);\nlist = filterWithReduce(list, isOdd);\nlist.reduce(sum); // 42\n\n// 3: Extracting the utilities\nfunction mapWithReduce(mappingFn) {\n  return function reducer(list, v) {\n    // specifically cutting a corner\n    // it is using mutation\n    list.push(mappingFn(v));\n    return list;\n  };\n}\n\nfunction filterWithReduce(predicateFn) {\n  return function reducer(list, v) {\n    if (predicateFn(v)) list.push(v);\n    return list;\n  };\n}\n\n// now we create a stream of reducers\nlist\n  .reduce(mapReducer(add1))\n  .reduce(filterReducer(isOdd))\n  .reduce(sum); // 42\n\n// 4: Instead, lets use a combiner\nfunction listCombination(list, v) {\n  list.push(v);\n  return list;\n}\n\nfunction mapWithReduce(mappingFn) {\n  return function reducer(list, v) {\n    return listCombination(list, mappingFn(v));\n  };\n}\n\nfunction filterWithReduce(predicateFn) {\n  return function reducer(list, v) {\n    if (predicateFn(v)) return listCombination(list, mappingFn(v));\n    return list;\n  };\n}\n\nlist\n  .reduce(mapReducer(add1))\n  .reduce(filterReducer(isOdd))\n  .reduce(sum); // 42\n\n// 5. Passing listCombination as a parameter\nfunction listCombination(list, v) {\n  list.push(v);\n  return list;\n}\n\nvar mapWithReduce = curry(2, function mapReducer(mappingFn, combineFn) {\n  return function reducer(list, v) {\n    return combineFn(list, mappingFn(v));\n  };\n});\n\nvar filterWithReduce = curry(2, function filterReducer(predicateFn, combineFn) {\n  return function reducer(list, v) {\n    if (predicateFn(v)) return combineFn(list, mappingFn(v));\n    return list;\n  };\n});\n\nlist\n  // returns Higher Order Reducers waiting for reducer\n  .reduce(mapReducer(add1)(listCombimation), [])\n  .reduce(filterReducer(isOdd)(listCombimation), [])\n  .reduce(sum); // 42\n")),Object(a.b)("p",null,"The end goal here was to turn our functions into higher order reducers waiting for a reducer."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Again, the idea of currying is to creating specialisation instead of generalisation (in this case, towards the unary function).")),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function listCombination(list, v) {\n  list.push(v);\n  return list;\n}\n\nvar mapWithReduce = curry(2, function mapReducer(mappingFn, combineFn) {\n  return function reducer(list, v) {\n    return combineFn(list, mappingFn(v));\n  };\n});\n\nvar filterWithReduce = curry(2, function filterReducer(predicateFn, combineFn) {\n  return function reducer(list, v) {\n    if (predicateFn(v)) return combineFn(list, mappingFn(v));\n    return list;\n  };\n});\n\n// Each function gets a reducer out\n// we are now thinking of reducers\n// travelling through the composition\n// and not numbers.\nvar transducer = compose(\n  mapReducer(add1),\n  filterReducer(isOdd),\n);\n\nlist\n  // returns Higher Order Reducers waiting for reducer\n  .reduce(transducer(listCombination), [])\n  .reduce(sum); // 42\n")),Object(a.b)("p",null,"After all of this work, we have one step. ",Object(a.b)("inlineCode",{parentName:"p"},"listCombination")," is essentially a sum function."),Object(a.b)("p",null,"Because of this, we don't even need our intermediate array! What's the point if the list will just get reduced?"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"var mapWithReduce = curry(2, function mapReducer(mappingFn, combineFn) {\n  return function reducer(list, v) {\n    return combineFn(list, mappingFn(v));\n  };\n});\n\nvar filterWithReduce = curry(2, function filterReducer(predicateFn, combineFn) {\n  return function reducer(list, v) {\n    if (predicateFn(v)) return combineFn(list, mappingFn(v));\n    return list;\n  };\n});\n\n// Each function gets a reducer out\n// we are now thinking of reducers\n// travelling through the composition\n// and not numbers.\nvar transducer = compose(\n  mapReducer(add1),\n  filterReducer(isOdd),\n);\n\nlist.reduce(transducer(sum), 0); // 42\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"All that's done here is use everything spoken in the course so far. Abstraction, currying etc.")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Reducers always need an initial value. Whatever you pass to the transducer is what we want to get at the end. Instead of sum, could have been a string concater, could be a list builder.")),Object(a.b)("h2",{id:"data-structure-operations"},"Data Structure Operations"),Object(a.b)("p",null,"Say we wanted to lowercase the properties of an object:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"var obj = {\n  name: 'Dennis',\n  email: 'Test@Gmail.com',\n};\n\nfunction mapObj(mapper, o) {\n  var newObj = {};\n  for (let key of Object.keys(o)) {\n    newObj[hey] = mapper(o[key]);\n  }\n  return newObj;\n}\n\nmapObg(function lower(val) {\n  return val.toLowerCase();\n}, obj);\n// { name: \"kyle\", email: \"test@gmail.com\" }\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Think of map as lifting an operation to a list of values in a container.")),Object(a.b)("p",null,"So what would filter and reduce look like in an object sense?"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function filterObj(predicateFn, o) {\n  var newObj = {};\n  for (let key of Object.keys(o)) {\n    if (predicateFn(o[key])) newObj[hey] = mapper(o[key]);\n  }\n  return newObj;\n}\n\nfunction reduceObj(reducerFn, initialValue, o) {\n  var result = initialValue;\n  for (let key of Object.keys(o)) {\n    result = reducerFn(result, o[key]);\n  }\n  return result;\n}\n")),Object(a.b)("p",null,"Now we want to do some refactoring using the pieces that we already know:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// 1. Transforming what we already have\nvar filteredNums = filterObj(function(list) {\n  return isOdd(listSum(list));\n}, nums);\n\nvar filteredNumsProduct = mapObj(function(list) {\n  return listProduct(list);\n}, filteredNums);\n\nreduceObj(\n  function(acc, v) {\n    return acc + v;\n  },\n  0,\n  filteredNumsProducts,\n); // 38886\n\n// 2. Transforming to be point free\npipe(\n  curry(2)(\n    filterObj(\n      compose(\n        isOdd,\n        listSum,\n      ),\n    ),\n  ),\n  curry(2)(mapObj(listProduct, filteredNums)),\n  curry(2)(reduceObj),\n)(nums); // 38886\n\n// 3. Remove the repetitiveness\n// binary used to reduce arity\n[\n  curry(2)(\n    filterObj(\n      compose(\n        isOdd,\n        listSum,\n      ),\n    ),\n  ),\n  curry(2)(mapObj(listProduct, filteredNums)),\n  curry(2)(reduceObj),\n].reduce(binary(pipe))(nums); // 38886\n")),Object(a.b)("h2",{id:"monad-data-structure"},"Monad Data Structure"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},'Monad is a way of creating a functional-friendly data structure. "A monoid in the category of endofunctors." In laymen terms: a pattern for pairing data with a set of predictable behaviours that let it interact with other data + behaviour pairings (other monads).')),Object(a.b)("p",null,"Why do I need a data structure for one value? It is a wrapper with a set of behaviours with it that allow it to be friendly to functional concepts."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// a wrapper around a single value\nfunction Just(val) {\n  // these are the three cores methods on the monads\n  return { map, chain, ap };\n}\n")),Object(a.b)("p",null,"How might we implement these as an example? Note: this is not strictly an accurate representation of these functions in the wild."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// a wrapper around a single value\nfunction Just(val) {\n  function map(fn) {\n    return Just(fn(val));\n  }\n\n  // aka bind, flatMap\n  function chain(fn) {\n    return fn(val);\n  }\n\n  // the monad, of course, must have a map\n  function ap(anotherMonad) {\n    return anotherMonad.map(val);\n  }\n\n  // these are the three cores methods on the monads\n  return { map, chain, ap };\n}\n\n// in action\nvar fortyOne = Just(41);\nvar forthTwo = fortyOne.map(function inc(v) {\n  return v + 1;\n});\n\nfunction identity(v) {\n  return v;\n}\n\n// debug inspection - note: violating monad laws\nfortyOne.chain(identity); // 41\nfortyTwo.chain(identity); // 42\nfortyOne.map(identity); // Just(41)\n\nvar user1 = Just('Kyle');\nvar user2 = Just('Susan');\n\n// is a reducer shape\nvar tuple = curry(2, function tuple(x, y) {\n  return [x, y];\n});\n\nvar users = user1.map(tuple).ap(user2);\n['Kyle', 'Susan'];\n")),Object(a.b)("h2",{id:"maybe-monad"},"Maybe Monad"),Object(a.b)("p",null,"One of the most common uses of the monads."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"var someObj = {\n  something: {\n    else: {\n      entirely: 42,\n    },\n  },\n};\n\nsomeObj.something.else.entirely; // 42\n")),Object(a.b)("p",null,"What happens when one of the properties is undefined? To understand, we need a nothing monad."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// Nothing becomes a blackhole of Nothingness ie no-op\nfunction Nothing() {\n  return { map: Nothing, chain: Nothing, ap: Nothing };\n}\n\nvar Maybe = { Just, Nothing, of: Just };\n\n// critical behaviour to give us another monad\nfunction fromNullable(val) {\n  if (val == null) return Maybe.Nothing();\n  else return Maybe.of(val);\n}\n\n// will give back Nothing or Just monad\nvar prop = curry(2, function prop(prop, obj) {\n  return fromNullable(obj[prop]);\n});\n\nMaybe.of(someObj)\n  .chain(prop('something'))\n  .chain(prop('else'))\n  .chain(prop('entirely'))\n  .chain(identity); // 42 - the value of the deep nested object\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Should you use monads? Maybe. Just don't be scared of them. - Kyle")),Object(a.b)("h2",{id:"async"},"Async"),Object(a.b)("p",null,"Here is an example of synchronous and eager operations:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"var = [1,2,3]\n\nvar b = a.map(function double(v) {\n  return v * 2\n})\n\nb; // [2,4,6]\n")),Object(a.b)("p",null,"How can we do this in a lazy way?"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Kyle here asks the question on what could it look like if we had a ",Object(a.b)("inlineCode",{parentName:"p"},"lazyMap")," function or a ",Object(a.b)("inlineCode",{parentName:"p"},"lazyArray")," data structure.")),Object(a.b)("p",null,"This is where ",Object(a.b)("inlineCode",{parentName:"p"},"observable")," comes through."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},'Kyle akins them to a spreadsheet. If you set A1 to 5 and B1 to A1 + 5, B1 is 10. What happens if you now change A1 to 10? B1 "magically" becomes 15.')),Object(a.b)("p",null,'Observables can "lift" our program to become time oriented.'),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},'"Lifting is when you take a value and put it into an object like a functor. If you lift a function into an Applicative Functor then you can make it work on values that are also in that functor." - ',Object(a.b)("a",o({parentName:"p"},{href:"https://github.com/hemanth/functional-programming-jargon#lift"}),"GitHub resource"))),Object(a.b)("h3",{id:"reactive-programming-with-rxjs"},"Reactive Programming with Rx.js"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"var a = new Rx.Subject();\n\nsetInterval(function everySecond() {\n  a.next(Math.random());\n}, 1000);\n\n// elsewhere\n\n// when you do Observable.map etc, you get another Observable!\nvar b = a.map(function double(v) {\n  return v * 2;\n});\n\n// subscribe to changes like b\nb.subscribe(function onValue(v) {\n  console.log(v);\n});\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Note: Kyle says that if you think about Event-Oriented programming, then terms have about 80% crossover ie observables, event streaming etc.")),Object(a.b)("h3",{id:"map-lazy-and-lazy-array"},"Map Lazy and Lazy Array"),Object(a.b)("h2",{id:"functional-js-utils"},"Functional JS Utils"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Lodash/FP - note, it is not Lodash"),Object(a.b)("li",{parentName:"ol"},"Ramda"),Object(a.b)("li",{parentName:"ol"},"FPO")),Object(a.b)("h3",{id:"lodashfp"},"Lodash/FP"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"fp.reduce((acc, v) => acc + v), 0, [3,7,9]) // 19\n\nvar f = fp.curryN(3, function f(x,y,z) {\n  return x + (y * z)\n})\nvar g = fp.compose([fp.add(1), f(1,4)])\ng(10) // 42\n")),Object(a.b)("h3",{id:"ramda"},"Ramda"),Object(a.b)("p",null,"One of the most popular of the libraries out there."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"R.reduce((acc, v) => acc + v), 0, [3,7,9]) // 19\n\nvar f = R.curryN(3, function f(x,y,z) {\n  return x + (y * z)\n})\nvar g = R.compose(R.inc, f(1,4))\ng(10) // 42\n")),Object(a.b)("h3",{id:"fpo"},"FPO"),Object(a.b)("p",null,"One that Kyle wrote, initially to be a wrapper on top of Ramda."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"// traditional on the FPO.std namespace\nFPO.std.reduce((acc, v) => acc + v), undefined, [3,7,9]) // 19\n\n// named arguments\nFPO.reduce({arr: [3,7,9], fn: ({acc, v}) => acc + v}) // 19\n\n// comparing\nvar f = curry(2, flip(partialRight(reduce, [[3,7,9]])))\n\nf((acc,v) => acc + v) // 19\nf((acc,v) => acc * v) // 189\n\nvar f = FPO.reduce({arr: [3,7,9]})\n\nf({fn: ({acc,v}) => acc + v}) // 19\nf({fn: ({acc,v}) => acc * v}) // 189\n")))}u&&u===Object(u)&&Object.isExtensible(u)&&!u.hasOwnProperty("__filemeta")&&Object.defineProperty(u,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"manual/JavaScript/Functional-Light-JavaScript-v3.md"}}),u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---manual-java-script-functional-light-java-script-v-3-md-8e6c3ab5e74005bff6d5.js.map