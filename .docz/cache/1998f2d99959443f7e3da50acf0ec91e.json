{"remainingRequest":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js??ref--6-2!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js!/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/JavaScript/JS-D3-Udemy.md","dependencies":[{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/JavaScript/JS-D3-Udemy.md","mtime":1562563032045},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/cache-loader/dist/cjs.js","mtime":1564095360956},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1562568123838},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js","mtime":1565139338792},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js","mtime":1564095361765}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIi9Vc2Vycy9kZW5uaXMub2tlZWZmZS9Qcm9qZWN0LUltcG9zdGVyL2RldmVsb3Blci1ub3Rlcy9ub2RlX21vZHVsZXMvYmFiZWwtcHJlc2V0LXJlYWN0LWFwcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiOy8qIEBqc3ggbWR4ICovaW1wb3J0IFJlYWN0IGZyb20ncmVhY3QnO2ltcG9ydHttZHh9ZnJvbSdAbWR4LWpzL3JlYWN0JzsvKiBAanN4IG1keCAqL3ZhciBtYWtlU2hvcnRjb2RlPWZ1bmN0aW9uIG1ha2VTaG9ydGNvZGUobmFtZSl7cmV0dXJuIGZ1bmN0aW9uIE1EWERlZmF1bHRTaG9ydGNvZGUocHJvcHMpe2NvbnNvbGUud2FybigiQ29tcG9uZW50ICIrbmFtZSsiIHdhcyBub3QgaW1wb3J0ZWQsIGV4cG9ydGVkLCBvciBwcm92aWRlZCBieSBNRFhQcm92aWRlciBhcyBnbG9iYWwgc2NvcGUiKTtyZXR1cm4gbWR4KCJkaXYiLHByb3BzKTt9O307dmFyIGxheW91dFByb3BzPXt9O3ZhciBNRFhMYXlvdXQ9IndyYXBwZXIiO2V4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQoX3JlZil7dmFyIGNvbXBvbmVudHM9X3JlZi5jb21wb25lbnRzLHByb3BzPV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLFsiY29tcG9uZW50cyJdKTtyZXR1cm4gbWR4KE1EWExheW91dCxPYmplY3QuYXNzaWduKHt9LGxheW91dFByb3BzLHByb3BzLHtjb21wb25lbnRzOmNvbXBvbmVudHMsbWR4VHlwZToiTURYTGF5b3V0In0pLG1keCgiaDIiLHsiaWQiOiJyZWFkaW5nLXRoZS1kMy1kb2N1bWVudGF0aW9uIn0sIlJlYWRpbmcgdGhlIEQzIERvY3VtZW50YXRpb24iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiLSBbUmVhZGluZyB0aGUgRDMgRG9jdW1lbnRhdGlvbl0oI3JlYWRpbmctdGhlLWQzLWRvY3VtZW50YXRpb24pXG4tIFttYXAoKSBhbmQgZmlsdGVyKCkgbWV0aG9kc10oI21hcC1hbmQtZmlsdGVyLW1ldGhvZHMpXG4tIFtkMyBtZXRob2RzXSgjZDMtbWV0aG9kcylcbi0gW1Byb2dyYW1tYXRpYyBTVkdzXSgjcHJvZ3JhbW1hdGljLXN2Z3MpXG4tIFtTY2FsaW5nIERhdGFdKCNzY2FsaW5nLWRhdGEpXG4tIFtTdHlsaW5nIHdpdGggQ1NTXSgjc3R5bGluZy13aXRoLWNzcylcbi0gW0FkZGluZyBUZXh0IHRvIHRoZSBjaGFydF0oI2FkZGluZy10ZXh0LXRvLXRoZS1jaGFydClcbi0gW1VzaW5nIFNWRyBncm91cHNdKCN1c2luZy1zdmctZ3JvdXBzKVxuIikpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJhIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJsaSJ9LHsiaHJlZiI6IiNzZWN0aW9uLTQtbWFraW5nLWEtY29tcGxleC1jaGFydCJ9KSwiU2VjdGlvbiA0OiBNYWtpbmcgYSBDb21wbGV4IENoYXJ0IiksbWR4KCJ1bCIse3BhcmVudE5hbWU6ImxpIn0sbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJhIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJsaSJ9LHsiaHJlZiI6IiN3b3JraW5nLXdpdGgtYXJyYXlzLW9mLW9iamVjdHMifSksIldvcmtpbmcgd2l0aCBBcnJheXMgb2YgT2JqZWN0cyIpKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSxtZHgoImEiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6ImxpIn0seyJocmVmIjoiI2NyZWF0aW5nLWFuLW9yZGluYWwtc2NhbGUifSksIkNyZWF0aW5nIGFuIE9yZGluYWwgU2NhbGUiKSksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJhIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJsaSJ9LHsiaHJlZiI6IiNzZXR0aW5nLWNvbG91ci13aXRoLWNvbG91ci1zY2FsZXMifSksIlNldHRpbmcgY29sb3VyIHdpdGggY29sb3VyIHNjYWxlcyIpKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSxtZHgoImEiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6ImxpIn0seyJocmVmIjoiI2FkZGluZy14LWFuZC15LWF4aXMifSksIkFkZGluZyBYIGFuZCBZIGF4aXMiKSksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJhIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJsaSJ9LHsiaHJlZiI6IiNmbGlwcGluZy10aGUtYXhlcyJ9KSwiRmxpcHBpbmcgdGhlIGF4ZXMiKSksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJhIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJsaSJ9LHsiaHJlZiI6IiNhZGRpbmctZ3JpZGxpbmVzIn0pLCJBZGRpbmcgR3JpZGxpbmVzIikpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgiYSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToibGkifSx7ImhyZWYiOiIjcm90YXRpbmctdGhlLXgtYXhpcy10aXRsZXMifSksIlJvdGF0aW5nIHRoZSBYIGF4aXMgdGl0bGVzIikpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgiYSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToibGkifSx7ImhyZWYiOiIjYWRkaW5nLWF4aXMtbGFiZWxzIn0pLCJBZGRpbmcgYXhpcyBsYWJlbHMiKSksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJhIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJsaSJ9LHsiaHJlZiI6IiN1cGRhdGluZy10aGUtcGxvdC1mdW5jdGlvbi13aXRoLWJlc3QtcHJhY3Rpc2VzIn0pLCJVcGRhdGluZyB0aGUgcGxvdCBmdW5jdGlvbiB3aXRoIGJlc3QgcHJhY3Rpc2VzIikpKSksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJhIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJsaSJ9LHsiaHJlZiI6IiNzZWNvbnRpb24tNS1tYWtpbmctdGhlLWNoYXJ0LWludGVyYWN0aXZlIn0pLCJTZWNvbnRpb24gNTogTWFraW5nIHRoZSBDaGFydCBJbnRlcmFjdGl2ZSIpKSksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiQVBJIERvY3VtZW50YXRpb24gaXMgYSBncmVhdCBsaW5rIHRvIGJvb2ttYXJrIikpLG1keCgiaHIiLG51bGwpLG1keCgiaDIiLHsiaWQiOiJtYXAtYW5kLWZpbHRlci1tZXRob2RzIn0sIm1hcCgpIGFuZCBmaWx0ZXIoKSBtZXRob2RzIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksInZhciBkYXRhID0gWzEyMywgNTIsIDQ2LCAzMCwgNF07XG5cbmNvbnN0IHJlc3VsdHMgPSBkYXRhLmZpbHRlcigoZW50cnkpID0+IHtcbiAgICByZXR1cm4gZW50cnkgPiA1MDtcbn0pO1xuXG5jb25zdCBtYXBwaW5nID0gZGF0YS5tYXAoKGVudHJ5KSA9PiB7XG4gICAgY29uc29sZS5sb2coZW50cnkua2V5KTtcbiAgICBjb25zb2xlLmxvZyhlbnRyeS52YWx1ZSk7XG59KTtcbiIpKSxtZHgoImhyIixudWxsKSxtZHgoImgyIix7ImlkIjoiZDMtbWV0aG9kcyJ9LCJkMyBtZXRob2RzIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksImNvbnN0IGV4YW1wbGUgPSBkMy5taW4oZGF0YSk7XG5jb25zb2xlLmxvZyhleGFtcGxlKTsgICAgICAgLy8gdmFsdWVzIHJldHVybmVkXG5cbmNvbnN0IGRhdGFMb0hpVmFsdWUgPSBkMy5leHRlbnQoZGF0YSk7ICAvLyByZXR1cm4gbWluL21heCBhcyBhcnJheVxuXG52YXIgZGljdE1pblZhbHVlID0gZDMubWluKGRvdW50cywgKGQsIGkpIHtcbiAgICByZXR1cm4gZC52YWx1ZTtcbn0pO1xuIikpLG1keCgiaHIiLG51bGwpLG1keCgiaDIiLHsiaWQiOiJwcm9ncmFtbWF0aWMtc3ZncyJ9LCJQcm9ncmFtbWF0aWMgU1ZHcyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCJ2YXIgZGF0YSA9IFsxMzIsNzEsMzM3LDkzLDc4LDQzLDIwLDE2LDMwLDgsMTcsMjFdO1xubGV0IHN2ZyA9IGQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnc3ZnJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnY2hhcnQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCA0NTApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgODAwKTtcblxuLy8gY3JlYXRpbmcgdGhlIGJhcnNcbi8vIHZlcnRpY2FsIGJhciBncmFwaFxuc3ZnLnNlbGVjdEFsbCgnLmJhcicpXG4gICAgLmRhdGEoZGF0YSlcbiAgICAuZW50ZXIoKSAgICAgICAgICAgICAgICAvLyBlbnRlciBwaGFzZVxuICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgIC5hdHRyKCdjbGFzcycsICdiYXInKSAgIC8vIGZvciBmdXR1cmUgc2VsZWN0aW9uc1xuICAgIC5hdHRyKCd4JywgMClcbiAgICAuYXR0cigneScsIChkIGkpID0+IHtcbiAgICAgICAgcmV0dXJuIGkgKiAyMDtcbiAgICB9KVxuICAgIC5hdHRyKCd3aWR0aCcsIChkLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH0pXG4gICAgLmF0dHIoJ2hlaWdodCcsIDE5KTtcbiIpKSxtZHgoImgyIix7ImlkIjoic2NhbGluZy1kYXRhIn0sIlNjYWxpbmcgRGF0YSIpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkNyZWF0aW5nIHNjYWxpbmcgZnVuY3Rpb25zIGZvciBib3RoIHggYW5kIHkuIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCJ2YXIgZGF0YSA9IFsxMzIsIDcxLCAzMzcsIDkzLCA3OCwgNDMsIDIwLCAxNiwgMzAsIDgsIDE3LCAyMV07XG5sZXQgdyA9IDgwMDtcbmxldCBoID0gNDUwO1xubGV0IHggPSBkMy5zY2FsZVxuICAgIC5saW5lYXIoKVxuICAgIC5kb21haW4oWzAsIGQzLm1heChkYXRhKV0pXG4gICAgLnJhbmdlKFswLCB3XSk7XG5sZXQgeSA9IGQzLnNjYWxlXG4gICAgLmxpbmVhcigpXG4gICAgLmRvbWFpbihbMCwgZGF0YS5sZW5ndGhdKVxuICAgIC5yYW5nZShbMCwgaF0pO1xuXG5sZXQgc3ZnID0gZDNcbiAgICAuc2VsZWN0KCdib2R5JylcbiAgICAuYXBwZW5kKCdzdmcnKVxuICAgIC5hdHRyKCdpZCcsICdjaGFydCcpXG4gICAgLmF0dHIoJ2hlaWdodCcsIGgpXG4gICAgLmF0dHIoJ3dpZHRoJywgdyk7XG5cbi8vIGNyZWF0aW5nIHRoZSBiYXJzXG4vLyB2ZXJ0aWNhbCBiYXIgZ3JhcGhcbnN2Z1xuICAgIC5zZWxlY3RBbGwoJy5iYXInKVxuICAgIC5kYXRhKGRhdGEpXG4gICAgLmVudGVyKCkgLy8gZW50ZXIgcGhhc2VcbiAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAuYXR0cignY2xhc3MnLCAnYmFyJykgLy8gZm9yIGZ1dHVyZSBzZWxlY3Rpb25zXG4gICAgLmF0dHIoJ3gnLCAwKVxuICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHtcbiAgICAgICAgcmV0dXJuIHkoaSk7XG4gICAgfSlcbiAgICAuYXR0cignd2lkdGgnLCAoZCwgaSkgPT4ge1xuICAgICAgICByZXR1cm4geChkKTsgLy8geCgpIGRvZXMgdGhlIHNjYWxpbmdcbiAgICB9KVxuICAgIC5hdHRyKCdoZWlnaHQnLCAoZCwgaSkgPT4ge1xuICAgICAgICByZXR1cm4geSgxKSAtIDE7XG4gICAgfSk7XG4iKSksbWR4KCJoMiIseyJpZCI6InN0eWxpbmctd2l0aC1jc3MifSwiU3R5bGluZyB3aXRoIENTUyIpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkdldHRpbmcgcmlkIG9mIHRoZSBhbGlhc2luZyIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtY3NzIn0pLCIuYmFyIHtcbiAgICBmaWxsOiBwdXJwbGU7XG59XG4iKSksbWR4KCJwIixudWxsLCJOb3QgdGhhdCAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwiYXR0cignY2xhc3MnLCAnYmFyJykiKSwiIHdpbGwgbWFudWFsbHkgcmVzZXQgdGhlIGNsYXNzIHZhbHVlLCBzbyB5b3UgY2FuIGFsc28gdXNlICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCIuY2xhc3NlZCgnYmFyJywgdHJ1ZSkiKSwiIC0gdHJ1ZSB0byBhZGQgdGhlIGNsYXNzLCBmYWxzZSB0byByZW1vdmUuIiksbWR4KCJoMiIseyJpZCI6ImFkZGluZy10ZXh0LXRvLXRoZS1jaGFydCJ9LCJBZGRpbmcgVGV4dCB0byB0aGUgY2hhcnQiKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJDcmVhdGluZyBzY2FsaW5nIGZ1bmN0aW9ucyBmb3IgYm90aCB4IGFuZCB5LiIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtamF2YXNjcmlwdCJ9KSwidmFyIGRhdGEgPSBbMTMyLCA3MSwgMzM3LCA5MywgNzgsIDQzLCAyMCwgMTYsIDMwLCA4LCAxNywgMjFdO1xubGV0IHcgPSA4MDA7XG5sZXQgaCA9IDQ1MDtcbmxldCB4ID0gZDMuc2NhbGVcbiAgICAubGluZWFyKClcbiAgICAuZG9tYWluKFswLCBkMy5tYXgoZGF0YSldKVxuICAgIC5yYW5nZShbMCwgd10pO1xubGV0IHkgPSBkMy5zY2FsZVxuICAgIC5saW5lYXIoKVxuICAgIC5kb21haW4oWzAsIGRhdGEubGVuZ3RoXSlcbiAgICAucmFuZ2UoWzAsIGhdKTtcblxubGV0IHN2ZyA9IGQzXG4gICAgLnNlbGVjdCgnYm9keScpXG4gICAgLmFwcGVuZCgnc3ZnJylcbiAgICAuYXR0cignaWQnLCAnY2hhcnQnKVxuICAgIC5hdHRyKCdoZWlnaHQnLCBoKVxuICAgIC5hdHRyKCd3aWR0aCcsIHcpO1xuXG5mdW5jdGlvbiBwbG90KHBhcmFtcykge1xuICAgIC8vIGNyZWF0aW5nIHRoZSBiYXJzXG4gICAgLy8gdmVydGljYWwgYmFyIGdyYXBoXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXInKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKCkgLy8gZW50ZXIgcGhhc2VcbiAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdiYXInKSAvLyBmb3IgZnV0dXJlIHNlbGVjdGlvbnNcbiAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQpOyAvLyB4KCkgZG9lcyB0aGUgc2NhbGluZ1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KDEpIC0gMTtcbiAgICAgICAgfSk7XG5cbiAgICB0aGlzLnNlbGVjdEFsbCgnLmJhci1sYWJlbCcpXG4gICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgLmNsYXNzZWQoJ2Jhci1sYWJlbCcsIHRydWUpXG4gICAgICAgIC5hdHRyKCd4JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQpOyAvLyB1c2UgY3NzIHRvIGNoYW5nZSB0aGUgYW5jaG9yXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeCcsIC00KVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2R5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KDEpIC8gMS41ICsgMjtcbiAgICAgICAgfSlcbiAgICAgICAgLnRleHQoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KTtcbn1cblxuLy8gZmlyc3QgYXJnIHdpbGwgYmUgd2hhdCBpcyByZWZlcmVuY2VkIGJ5IFwidGhpc1wiXG5wbG90LmNhbGwoc3ZnLCB7XG4gICAgZGF0YTogZGF0YVxufSk7XG4iKSksbWR4KCJoMiIseyJpZCI6InVzaW5nLXN2Zy1ncm91cHMifSwiVXNpbmcgU1ZHIGdyb3VwcyIpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIlNWRyBncm91cHMgYXJlIGxpa2UgYSBkaXYgdGhhdCBhcmUgYSBjb252ZW5pZW5jZSBlbGVtZW50IHRvIGFsbG93IGNoaWxkcmVuIHRvIGJlIG1vdmVkIGFuZCBhZmZlY3RlZCB0b2dldGhlci4iKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksInZhciBkYXRhID0gWzEzMiwgNzEsIDMzNywgOTMsIDc4LCA0MywgMjAsIDE2LCAzMCwgOCwgMTcsIDIxXTtcbmxldCB3ID0gODAwO1xubGV0IGggPSA0NTA7XG5sZXQgbWFyZ2luID0ge1xuICAgIHRvcDogMjAsXG4gICAgYm90dG9tOiAyMCxcbiAgICBsZWZ0OiAyMCxcbiAgICByaWdodDogMjBcbn07XG5cbnZhciB3aWR0aCA9IHcgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbnZhciBoZWlnaHQgPSBoIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbmxldCB4ID0gZDMuc2NhbGVcbiAgICAubGluZWFyKClcbiAgICAuZG9tYWluKFswLCBkMy5tYXgoZGF0YSldKVxuICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcbmxldCB5ID0gZDMuc2NhbGVcbiAgICAubGluZWFyKClcbiAgICAuZG9tYWluKFswLCBkYXRhLmxlbmd0aF0pXG4gICAgLnJhbmdlKFswLCBoZWlnaHRdKTtcblxubGV0IHN2ZyA9IGQzXG4gICAgLnNlbGVjdCgnYm9keScpXG4gICAgLmFwcGVuZCgnc3ZnJylcbiAgICAuYXR0cignaWQnLCAnY2hhcnQnKVxuICAgIC5hdHRyKCdoZWlnaHQnLCBoKVxuICAgIC5hdHRyKCd3aWR0aCcsIHcpO1xuXG5sZXQgY2hhcnQgPSBzdmdcbiAgICAuYXBwZW5kKCdnJylcbiAgICAuY2xhc3NlZCgnZGlzcGxheScsIHRydWUpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMjAsIDIwKScpO1xuXG5mdW5jdGlvbiBwbG90KHBhcmFtcykge1xuICAgIC8vIGNyZWF0aW5nIHRoZSBiYXJzXG4gICAgLy8gdmVydGljYWwgYmFyIGdyYXBoXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXInKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKCkgLy8gZW50ZXIgcGhhc2VcbiAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdiYXInKSAvLyBmb3IgZnV0dXJlIHNlbGVjdGlvbnNcbiAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQpOyAvLyB4KCkgZG9lcyB0aGUgc2NhbGluZ1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KDEpIC0gMTtcbiAgICAgICAgfSk7XG5cbiAgICB0aGlzLnNlbGVjdEFsbCgnLmJhci1sYWJlbCcpXG4gICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgLmNsYXNzZWQoJ2Jhci1sYWJlbCcsIHRydWUpXG4gICAgICAgIC5hdHRyKCd4JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQpOyAvLyB1c2UgY3NzIHRvIGNoYW5nZSB0aGUgYW5jaG9yXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeCcsIC00KVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2R5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KDEpIC8gMS41ICsgMjtcbiAgICAgICAgfSlcbiAgICAgICAgLnRleHQoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KTtcbn1cblxuLy8gZmlyc3QgYXJnIHdpbGwgYmUgd2hhdCBpcyByZWZlcmVuY2VkIGJ5IFwidGhpc1wiXG5wbG90LmNhbGwoY2hhcnQsIHtcbiAgICBkYXRhOiBkYXRhXG59KTtcbiIpKSxtZHgoImhyIixudWxsKSxtZHgoImgxIix7ImlkIjoic2VjdGlvbi00LW1ha2luZy1hLWNvbXBsZXgtY2hhcnQifSwiU2VjdGlvbiA0OiBNYWtpbmcgYSBDb21wbGV4IENoYXJ0IiksbWR4KCJoMiIseyJpZCI6Indvcmtpbmctd2l0aC1hcnJheXMtb2Ytb2JqZWN0cyJ9LCJXb3JraW5nIHdpdGggQXJyYXlzIG9mIE9iamVjdHMiKSxtZHgoInAiLG51bGwsIklmIHdvcmtpbmcgd2l0aCBhIGRpY3QsIHdlIG5lZWQgYW4gYWNjZXNzb3IgZnVuY3Rpb24hIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksInZhciBkYXRhID0gW1xuICAgIHsga2V5OiAnR2xhemVkJywgdmFsdWU6IDEzMiB9LFxuICAgIHsga2V5OiAnSmVsbHknLCB2YWx1ZTogNzEgfSxcbiAgICB7IGtleTogJ0hvbGVzJywgdmFsdWU6IDMzNyB9LFxuICAgIHsga2V5OiAnU3ByaW5rbGVzJywgdmFsdWU6IDkzIH0sXG4gICAgeyBrZXk6ICdDcnVtYicsIHZhbHVlOiA3OCB9LFxuICAgIHsga2V5OiAnQ2hvY29sYXRlJywgdmFsdWU6IDQzIH0sXG4gICAgeyBrZXk6ICdDb2NvbnV0JywgdmFsdWU6IDIwIH0sXG4gICAgeyBrZXk6ICdDcmVhbScsIHZhbHVlOiAxNiB9LFxuICAgIHsga2V5OiAnQ3J1bGxlcicsIHZhbHVlOiAzMCB9LFxuICAgIHsga2V5OiAnXHhDOWNsYWlyJywgdmFsdWU6IDggfSxcbiAgICB7IGtleTogJ0ZyaXR0ZXInLCB2YWx1ZTogMTcgfSxcbiAgICB7IGtleTogJ0JlYXJjbGF3JywgdmFsdWU6IDIxIH1cbl07XG5cbmxldCB3ID0gODAwO1xubGV0IGggPSA0NTA7XG5sZXQgbWFyZ2luID0ge1xuICAgIHRvcDogMjAsXG4gICAgYm90dG9tOiAyMCxcbiAgICBsZWZ0OiAyMCxcbiAgICByaWdodDogMjBcbn07XG5cbnZhciB3aWR0aCA9IHcgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbnZhciBoZWlnaHQgPSBoIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbmxldCB4ID0gZDMuc2NhbGVcbiAgICAubGluZWFyKClcbiAgICAuZG9tYWluKFtcbiAgICAgICAgMCxcbiAgICAgICAgZDMubWF4KGRhdGEsIChkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZC52YWx1ZTtcbiAgICAgICAgfSlcbiAgICBdKVxuICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcblxubGV0IHkgPSBkMy5zY2FsZVxuICAgIC5saW5lYXIoKVxuICAgIC5kb21haW4oWzAsIGRhdGEubGVuZ3RoXSlcbiAgICAucmFuZ2UoWzAsIGhlaWdodF0pO1xuXG5sZXQgc3ZnID0gZDNcbiAgICAuc2VsZWN0KCdib2R5JylcbiAgICAuYXBwZW5kKCdzdmcnKVxuICAgIC5hdHRyKCd3aWR0aCcsIDgwMClcbiAgICAuYXR0cignaGVpZ2h0JywgNDIwKVxuICAgIC5hdHRyKCdpZCcsICdjaGFydCcpO1xubGV0IGNoYXJ0ID0gc3ZnXG4gICAgLmFwcGVuZCgnZycpXG4gICAgLmNsYXNzZWQoJ2Rpc3BsYXknLCB0cnVlKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDIwLCAyMCknKTtcblxuZnVuY3Rpb24gcGxvdChwYXJhbXMpIHtcbiAgICAvLyBjcmVhdGluZyB0aGUgYmFyc1xuICAgIC8vIHZlcnRpY2FsIGJhciBncmFwaFxuICAgIHRoaXMuc2VsZWN0QWxsKCcuYmFyJylcbiAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgIC5lbnRlcigpIC8vIGVudGVyIHBoYXNlXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYmFyJykgLy8gZm9yIGZ1dHVyZSBzZWxlY3Rpb25zXG4gICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoaSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkLnZhbHVlKTsgLy8geCgpIGRvZXMgdGhlIHNjYWxpbmdcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geSgxKSAtIDE7XG4gICAgICAgIH0pO1xuXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXItbGFiZWwnKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgIC5jbGFzc2VkKCdiYXItbGFiZWwnLCB0cnVlKVxuICAgICAgICAuYXR0cigneCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkLnZhbHVlKTsgLy8gdXNlIGNzcyB0byBjaGFuZ2UgdGhlIGFuY2hvclxuICAgICAgICB9KVxuICAgICAgICAuYXR0cignZHgnLCAtNClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoaSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geSgxKSAvIDEuNSArIDI7XG4gICAgICAgIH0pXG4gICAgICAgIC50ZXh0KChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZC52YWx1ZTtcbiAgICAgICAgfSk7XG59XG5cbnBsb3QuY2FsbChjaGFydCwge1xuICAgIGRhdGE6IGRhdGFcbn0pO1xuIikpLG1keCgiaDIiLHsiaWQiOiJjcmVhdGluZy1hbi1vcmRpbmFsLXNjYWxlIn0sIkNyZWF0aW5nIGFuIE9yZGluYWwgU2NhbGUiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwidmFyIGRhdGEgPSBbXG4gICAge2tleTogXCJHbGF6ZWRcIiwgICAgIHZhbHVlOiAxMzJ9LFxuICAgIHtrZXk6IFwiSmVsbHlcIiwgICAgICB2YWx1ZTogNzF9LFxuICAgIHtrZXk6IFwiSG9sZXNcIiwgICAgICB2YWx1ZTogMzM3fSxcbiAgICB7a2V5OiBcIlNwcmlua2xlc1wiLCAgdmFsdWU6IDkzfSxcbiAgICB7a2V5OiBcIkNydW1iXCIsICAgICAgdmFsdWU6IDc4fSxcbiAgICB7a2V5OiBcIkNob2NvbGF0ZVwiLCAgdmFsdWU6IDQzfSxcbiAgICB7a2V5OiBcIkNvY29udXRcIiwgICAgdmFsdWU6IDIwfSxcbiAgICB7a2V5OiBcIkNyZWFtXCIsICAgICAgdmFsdWU6IDE2fSxcbiAgICB7a2V5OiBcIkNydWxsZXJcIiwgICAgdmFsdWU6IDMwfSxcbiAgICB7a2V5OiBcIlx4QzljbGFpclwiLCAgICAgdmFsdWU6IDh9LFxuICAgIHtrZXk6IFwiRnJpdHRlclwiLCAgICB2YWx1ZTogMTd9LFxuICAgIHtrZXk6IFwiQmVhcmNsYXdcIiwgICB2YWx1ZTogMjF9XG5dO1xuXG5sZXQgdyA9IDgwMDtcbmxldCBoID0gNDUwO1xubGV0IG1hcmdpbiA9IHtcbiAgICB0b3A6IDIwLFxuICAgIGJvdHRvbTogMjAsXG4gICAgbGVmdDogMjAsXG4gICAgcmlnaHQ6IDIwXG59O1xuXG52YXIgd2lkdGggPSB3IC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7XG52YXIgaGVpZ2h0ID0gaCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG5sZXQgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oWzAsIGQzLm1heChkYXRhLCAoZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgfSldKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG52YXIgeSA9IGQzLnNjYWxlLm9yZGluYWwoKSAgICAgICAgICAvLyBuZWVkIGRpc3RpbmN0IHZhbHVlcyBlZyBrZXlzXG4gICAgICAgIC5kb21haW4oZGF0YS5tYXAoKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkua2V5O1xuICAgICAgICB9KSlcbiAgICAgICAgLnJhbmdlQmFuZHMoWzAsIGhlaWdodF0pOyAgIC8vIHVzZWQgZm9yIGRpc3RpbmN0IHZhbHVlc1xuXG5sZXQgc3ZnID0gZDMuc2VsZWN0KCdib2R5JykuYXBwZW5kKCdzdmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgODAwKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDQyMClcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdjaGFydCcpO1xubGV0IGNoYXJ0ID0gc3ZnLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2Rpc3BsYXknLCB0cnVlKVxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgyMCwgMjApJyk7XG5cbmZ1bmN0aW9uIHBsb3QocGFyYW1zKSB7XG4gICAgLy8gY3JlYXRpbmcgdGhlIGJhcnNcbiAgICAvLyB2ZXJ0aWNhbCBiYXIgZ3JhcGhcbiAgICB0aGlzLnNlbGVjdEFsbCgnLmJhcicpXG4gICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAuZW50ZXIoKSAgICAgICAgICAgICAgICAvLyBlbnRlciBwaGFzZVxuICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JhcicpICAgLy8gZm9yIGZ1dHVyZSBzZWxlY3Rpb25zXG4gICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC5rZXkpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignd2lkdGgnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHgoZC52YWx1ZSk7ICAgICAgLy8geCgpIGRvZXMgdGhlIHNjYWxpbmdcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geS5yYW5nZUJhbmQoKSAtIDE7XG4gICAgICAgIH0pO1xuXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXItbGFiZWwnKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgIC5jbGFzc2VkKCdiYXItbGFiZWwnLCB0cnVlKVxuICAgICAgICAuYXR0cigneCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkLnZhbHVlKTsgICAgICAgICAgLy8gdXNlIGNzcyB0byBjaGFuZ2UgdGhlIGFuY2hvclxuICAgICAgICB9KVxuICAgICAgICAuYXR0cignZHgnLCAtNClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC5rZXkpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignZHknLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkucmFuZ2VCYW5kKCkvMS41KzI7XG4gICAgICAgIH0pXG4gICAgICAgIC50ZXh0KChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZC52YWx1ZTtcbiAgICAgICAgfSk7XG59XG5cbnBsb3QuY2FsbChjaGFydCwge1xuICAgIGRhdGE6IGRhdGFcbn0pO1xuIikpLG1keCgiaDIiLHsiaWQiOiJzZXR0aW5nLWNvbG91ci13aXRoLWNvbG91ci1zY2FsZXMifSwiU2V0dGluZyBjb2xvdXIgd2l0aCBjb2xvdXIgc2NhbGVzIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksInZhciBkYXRhID0gW1xuICAgIHtrZXk6IFwiR2xhemVkXCIsICAgICB2YWx1ZTogMTMyfSxcbiAgICB7a2V5OiBcIkplbGx5XCIsICAgICAgdmFsdWU6IDcxfSxcbiAgICB7a2V5OiBcIkhvbGVzXCIsICAgICAgdmFsdWU6IDMzN30sXG4gICAge2tleTogXCJTcHJpbmtsZXNcIiwgIHZhbHVlOiA5M30sXG4gICAge2tleTogXCJDcnVtYlwiLCAgICAgIHZhbHVlOiA3OH0sXG4gICAge2tleTogXCJDaG9jb2xhdGVcIiwgIHZhbHVlOiA0M30sXG4gICAge2tleTogXCJDb2NvbnV0XCIsICAgIHZhbHVlOiAyMH0sXG4gICAge2tleTogXCJDcmVhbVwiLCAgICAgIHZhbHVlOiAxNn0sXG4gICAge2tleTogXCJDcnVsbGVyXCIsICAgIHZhbHVlOiAzMH0sXG4gICAge2tleTogXCJceEM5Y2xhaXJcIiwgICAgIHZhbHVlOiA4fSxcbiAgICB7a2V5OiBcIkZyaXR0ZXJcIiwgICAgdmFsdWU6IDE3fSxcbiAgICB7a2V5OiBcIkJlYXJjbGF3XCIsICAgdmFsdWU6IDIxfVxuXTtcblxubGV0IHcgPSA4MDA7XG5sZXQgaCA9IDQ1MDtcbmxldCBtYXJnaW4gPSB7XG4gICAgdG9wOiAyMCxcbiAgICBib3R0b206IDIwLFxuICAgIGxlZnQ6IDIwLFxuICAgIHJpZ2h0OiAyMFxufTtcblxudmFyIHdpZHRoID0gdyAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xudmFyIGhlaWdodCA9IGggLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxubGV0IHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgKGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xuICAgIH0pXSlcbiAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xudmFyIHkgPSBkMy5zY2FsZS5vcmRpbmFsKCkgICAgICAgICAgLy8gbmVlZCBkaXN0aW5jdCB2YWx1ZXMgZWcga2V5c1xuICAgICAgICAuZG9tYWluKGRhdGEubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmtleTtcbiAgICAgICAgfSkpXG4gICAgICAgIC5yYW5nZUJhbmRzKFswLCBoZWlnaHRdKTsgICAvLyB1c2VkIGZvciBkaXN0aW5jdCB2YWx1ZXNcblxuLy8gYWx0ZXIgY29sb3VycyB1c2luZyBsaW5lYXIgc2NhbGVcbmxldCBsaW5lYXJDb2xvclNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4oWzAsIGRhdGEubGVuZ3RoXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yYW5nZShbJyM1NzI1MDAnLCAnI0Y2ODAyNiddKTtcblxuLy8gb3JkaW5hbCBmb3IgZGlzdGluY3QgY29sb3Vyc1xubGV0IG9yZGluYWxDb2xvclNjYWxlID0gZDMuc2NhbGUuY2F0ZWdvcnkyMCgpO1xuXG5sZXQgc3ZnID0gZDMuc2VsZWN0KCdib2R5JykuYXBwZW5kKCdzdmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgODAwKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDQyMClcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdjaGFydCcpO1xubGV0IGNoYXJ0ID0gc3ZnLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2Rpc3BsYXknLCB0cnVlKVxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgyMCwgMjApJyk7XG5cbmZ1bmN0aW9uIHBsb3QocGFyYW1zKSB7XG4gICAgLy8gY3JlYXRpbmcgdGhlIGJhcnNcbiAgICAvLyB2ZXJ0aWNhbCBiYXIgZ3JhcGhcbiAgICB0aGlzLnNlbGVjdEFsbCgnLmJhcicpXG4gICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAuZW50ZXIoKSAgICAgICAgICAgICAgICAvLyBlbnRlciBwaGFzZVxuICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JhcicpICAgLy8gZm9yIGZ1dHVyZSBzZWxlY3Rpb25zXG4gICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC5rZXkpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignd2lkdGgnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHgoZC52YWx1ZSk7ICAgICAgLy8geCgpIGRvZXMgdGhlIHNjYWxpbmdcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geS5yYW5nZUJhbmQoKSAtIDE7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbGluZWFyQ29sb3JTY2FsZShpKTtcbiAgICAgICAgfSk7XG5cbiAgICB0aGlzLnNlbGVjdEFsbCgnLmJhci1sYWJlbCcpXG4gICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgLmNsYXNzZWQoJ2Jhci1sYWJlbCcsIHRydWUpXG4gICAgICAgIC5hdHRyKCd4JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQudmFsdWUpOyAgICAgICAgICAvLyB1c2UgY3NzIHRvIGNoYW5nZSB0aGUgYW5jaG9yXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeCcsIC00KVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShkLmtleSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geS5yYW5nZUJhbmQoKS8xLjUrMjtcbiAgICAgICAgfSlcbiAgICAgICAgLnRleHQoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xuICAgICAgICB9KTtcbn1cblxucGxvdC5jYWxsKGNoYXJ0LCB7XG4gICAgZGF0YTogZGF0YVxufSk7XG4iKSksbWR4KCJoMiIseyJpZCI6ImFkZGluZy14LWFuZC15LWF4aXMifSwiQWRkaW5nIFggYW5kIFkgYXhpcyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIvLyBhZnRlciB0aGUgY29sb3VyIHNjYWxlc1xuXG5sZXQgeEF4aXMgPSBkMy5zdmcuYXhpcygpICAgICAgICAgICAvLyBzdmcgcG9ydGlvbiBvZiB0aGUgZDMgbGlicmFyeVxuICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgIC5vcmllbnQoJ2JvdHRvbScpO1xuXG5sZXQgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgLm9yaWVudCgnbGVmdCcpO1xuXG4uLi5cblxuZnVuY3Rpb24gcGxvdChwYXJhbXMpIHtcbiAgICAvLyBjcmVhdGluZyB0aGUgYmFyc1xuICAgIC8vIHZlcnRpY2FsIGJhciBncmFwaFxuICAgIHRoaXMuc2VsZWN0QWxsKCcuYmFyJylcbiAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgIC5lbnRlcigpICAgICAgICAgICAgICAgIC8vIGVudGVyIHBoYXNlXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYmFyJykgICAvLyBmb3IgZnV0dXJlIHNlbGVjdGlvbnNcbiAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShkLmtleSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkLnZhbHVlKTsgICAgICAvLyB4KCkgZG9lcyB0aGUgc2NhbGluZ1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5LnJhbmdlQmFuZCgpIC0gMTtcbiAgICAgICAgfSlcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lYXJDb2xvclNjYWxlKGkpO1xuICAgICAgICB9KTtcblxuICAgIHRoaXMuc2VsZWN0QWxsKCcuYmFyLWxhYmVsJylcbiAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAuY2xhc3NlZCgnYmFyLWxhYmVsJywgdHJ1ZSlcbiAgICAgICAgLmF0dHIoJ3gnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHgoZC52YWx1ZSk7ICAgICAgICAgIC8vIHVzZSBjc3MgdG8gY2hhbmdlIHRoZSBhbmNob3JcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2R4JywgLTQpXG4gICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KGQua2V5KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2R5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5LnJhbmdlQmFuZCgpLzEuNSsyO1xuICAgICAgICB9KVxuICAgICAgICAudGV4dCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgICAgIH0pO1xuICAgIHRoaXMuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCd4IGF4aXMnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIDAgICsgJywgJyArIGhlaWdodCAgKyAnKScpXG4gICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgdGhpcy5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3kgYXhpcycsIHRydWUpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCAwKScpXG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG59XG4iKSksbWR4KCJoMiIseyJpZCI6ImZsaXBwaW5nLXRoZS1heGVzIn0sIkZsaXBwaW5nIHRoZSBheGVzIiksbWR4KCJwIixudWxsLCJIb3cgdG8gY3JlYXRlIGEgY29sdW1uIGNoYXJ0PyIpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sImhlaWdodCBuZWVkcyB0byB0YWtlIGFuIG9mZnNldCIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJvdGhlciB2YWx1ZXMgZXNzZW50aWFsbHkgaW52ZXJ0IiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sInRleHQgYW5jaG9yIHdpbGwgYmUgIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJsaSJ9LCJtaWRkbGUiKSwiIGluIGNzcyIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwidmFyIGRhdGEgPSBbXG4gICAge2tleTogXCJHbGF6ZWRcIiwgICAgIHZhbHVlOiAxMzJ9LFxuICAgIHtrZXk6IFwiSmVsbHlcIiwgICAgICB2YWx1ZTogNzF9LFxuICAgIHtrZXk6IFwiSG9sZXNcIiwgICAgICB2YWx1ZTogMzM3fSxcbiAgICB7a2V5OiBcIlNwcmlua2xlc1wiLCAgdmFsdWU6IDkzfSxcbiAgICB7a2V5OiBcIkNydW1iXCIsICAgICAgdmFsdWU6IDc4fSxcbiAgICB7a2V5OiBcIkNob2NvbGF0ZVwiLCAgdmFsdWU6IDQzfSxcbiAgICB7a2V5OiBcIkNvY29udXRcIiwgICAgdmFsdWU6IDIwfSxcbiAgICB7a2V5OiBcIkNyZWFtXCIsICAgICAgdmFsdWU6IDE2fSxcbiAgICB7a2V5OiBcIkNydWxsZXJcIiwgICAgdmFsdWU6IDMwfSxcbiAgICB7a2V5OiBcIlx4QzljbGFpclwiLCAgICAgdmFsdWU6IDh9LFxuICAgIHtrZXk6IFwiRnJpdHRlclwiLCAgICB2YWx1ZTogMTd9LFxuICAgIHtrZXk6IFwiQmVhcmNsYXdcIiwgICB2YWx1ZTogMjF9XG5dO1xuXG5sZXQgdyA9IDgwMDtcbmxldCBoID0gNDUwO1xubGV0IG1hcmdpbiA9IHtcbiAgICB0b3A6IDIwLFxuICAgIGJvdHRvbTogMjAsXG4gICAgbGVmdDogMjAsXG4gICAgcmlnaHQ6IDIwXG59O1xuXG52YXIgd2lkdGggPSB3IC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7XG52YXIgaGVpZ2h0ID0gaCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG5sZXQgeCA9IGQzLnNjYWxlLm9yZGluYWwoKSAgICAgICAgICAvLyBuZWVkIGRpc3RpbmN0IHZhbHVlcyBlZyBrZXlzXG4gICAgICAgIC5kb21haW4oZGF0YS5tYXAoKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkua2V5O1xuICAgICAgICB9KSlcbiAgICAgICAgLnJhbmdlQmFuZHMoWzAsIGhlaWdodF0pOyAgIC8vIHVzZWQgZm9yIGRpc3RpbmN0IHZhbHVlc1xuXG5sZXQgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oWzAsIGQzLm1heChkYXRhLCAoZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgICAgIH0pXSlcbiAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKTsgICAgLy8gSU1QT1JUQU5UIENIQU5HRSBGUk9NIFswLCB3aWR0aF1cblxuLy8gYWx0ZXIgY29sb3VycyB1c2luZyBsaW5lYXIgc2NhbGVcbmxldCBsaW5lYXJDb2xvclNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4oWzAsIGRhdGEubGVuZ3RoXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yYW5nZShbJyM1NzI1MDAnLCAnI0Y2ODAyNiddKTtcblxuLy8gb3JkaW5hbCBmb3IgZGlzdGluY3QgY29sb3Vyc1xubGV0IG9yZGluYWxDb2xvclNjYWxlID0gZDMuc2NhbGUuY2F0ZWdvcnkyMCgpO1xuXG5sZXQgc3ZnID0gZDMuc2VsZWN0KCdib2R5JykuYXBwZW5kKCdzdmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgODAwKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDQyMClcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdjaGFydCcpO1xubGV0IGNoYXJ0ID0gc3ZnLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2Rpc3BsYXknLCB0cnVlKVxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgyMCwgMjApJyk7XG5cbmZ1bmN0aW9uIHBsb3QocGFyYW1zKSB7XG4gICAgLy8gY3JlYXRpbmcgdGhlIGJhcnNcbiAgICAvLyB2ZXJ0aWNhbCBiYXIgZ3JhcGhcbiAgICB0aGlzLnNlbGVjdEFsbCgnLmJhcicpXG4gICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAuZW50ZXIoKSAgICAgICAgICAgICAgICAvLyBlbnRlciBwaGFzZVxuICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JhcicpICAgLy8gZm9yIGZ1dHVyZSBzZWxlY3Rpb25zXG4gICAgICAgIC5hdHRyKCd4JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQua2V5KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC52YWx1ZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkLnZhbHVlKTsgICAgICAvLyB4KCkgZG9lcyB0aGUgc2NhbGluZ1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4LnJhbmdlQmFuZCgpO1xuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVhckNvbG9yU2NhbGUoaSk7XG4gICAgICAgIH0pO1xuXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXItbGFiZWwnKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgIC5jbGFzc2VkKCdiYXItbGFiZWwnLCB0cnVlKVxuICAgICAgICAuYXR0cigneCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkLnZhbHVlKTsgICAgICAgICAgLy8gdXNlIGNzcyB0byBjaGFuZ2UgdGhlIGFuY2hvclxuICAgICAgICB9KVxuICAgICAgICAuYXR0cignZHgnLCAtNClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC5rZXkpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignZHknLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkucmFuZ2VCYW5kKCkvMS41KzI7XG4gICAgICAgIH0pXG4gICAgICAgIC50ZXh0KChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZC52YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3ggYXhpcycsIHRydWUpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgMCAgKyAnLCAnICsgaGVpZ2h0ICArICcpJylcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcbiAgICAgICAgdGhpcy5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3kgYXhpcycsIHRydWUpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCAwKScpXG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG59XG5cbnBsb3QuY2FsbChjaGFydCwge1xuICAgIGRhdGE6IGRhdGFcbn0pO1xuIikpLG1keCgiaDIiLHsiaWQiOiJhZGRpbmctZ3JpZGxpbmVzIn0sIkFkZGluZyBHcmlkbGluZXMiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwidmFyIHlHcmlkbGluZXMgPSBkMy5zdmcuYXhpcygpICAgICAgICAgICAgICAvLyBjcmVhdGUgYW5vdGhlciBcImF4aXNcIlxuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC13aWR0aCwgMCwgMCkgICAgICAgICAgICAgLy8gdXNlZCB0byBhZGp1c3QgdGhlIGF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoJycpXG4gICAgICAgICAgICAgICAgICAgIC5vcmllbnQoJ2xlZnQnKTtcblxuLy8gYWRkIHRoZXNlIGdyaWQgbGluZXMgd2l0aCB0aGUgY2FsbCBmdW5jdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHBsb3QgZnVuY3Rpb25cbiIpKSxtZHgoInAiLG51bGwsIlRoZSBncmlkIGxpbmVzIGFsc28gbmVlZCB0byBiZSBzdHlsZWQhIEhpdCB1cCB0aGUgQ1NTIGZpbGUgdG8gZG8gdGhpcy4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiLmdyaWRsaW5lIHBhdGgsXG4uZ3JpZGxpbmUgbGluZSB7XG4gICAgZmlsbDogbm9uZTtcbiAgICBjb2xvcjogYmx1ZTtcbiAgICBzaGFwZS1yZW5kZXJpbmc6IGNyaXNwRWRnZXM7XG59XG4iKSksbWR4KCJoMiIseyJpZCI6InJvdGF0aW5nLXRoZS14LWF4aXMtdGl0bGVzIn0sIlJvdGF0aW5nIHRoZSBYIGF4aXMgdGl0bGVzIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIi4uLlxudGhpcy5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3ggYXhpcycsIHRydWUpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgMCAgKyAnLCAnICsgaGVpZ2h0ICArICcpJylcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKVxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeCcsIC04KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCA4KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLDApLCByb3RhdGUoLTQ1KScpO1xudGhpcy5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3kgYXhpcycsIHRydWUpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCAwKScpXG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4uLi5cbiIpKSxtZHgoImgyIix7ImlkIjoiYWRkaW5nLWF4aXMtbGFiZWxzIn0sIkFkZGluZyBheGlzIGxhYmVscyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIvLyB3aXRoaW4gdGhlIHBsb3QgZnVuY3Rpb24gYXQgdGhlIGJvdHRvbVxuXG50aGlzLnNlbGVjdCgnLnkuYXhpcycpXG4gICAgLmFwcGVuZCgndGV4dCcpXG4gICAgLmF0dHIoJ3gnLCAwKVxuICAgIC5hdHRyKCd5JywgMClcbiAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoLTUwLCAnICsgaGVpZ2h0IC8gMiArICcpIHJvdGF0ZSgtOTApJylcbiAgICAudGV4dCgnVW5pdHMgc29sZCcpO1xuXG50aGlzLnNlbGVjdCgnLnguYXhpcycpXG4gICAgLmFwcGVuZCgndGV4dCcpXG4gICAgLmF0dHIoJ3gnLCAwKVxuICAgIC5hdHRyKCd5JywgMClcbiAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHdpZHRoIC8gMiArICcsIDgwKSByb3RhdGUoLTkwKScpXG4gICAgLnRleHQoJ0RvbnV0IFR5cGUnKTtcbiIpKSxtZHgoImgyIix7ImlkIjoidXBkYXRpbmctdGhlLXBsb3QtZnVuY3Rpb24td2l0aC1iZXN0LXByYWN0aXNlcyJ9LCJVcGRhdGluZyB0aGUgcGxvdCBmdW5jdGlvbiB3aXRoIGJlc3QgcHJhY3Rpc2VzIiksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiQWRkIG5ldyBwYXJhbWV0ZXIgZW50cmllcy4iKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksInBsb3QuY2FsbChjaGFydCwge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgYXhpczoge1xuICAgICAgICB4OiB4QXhpcyxcbiAgICAgICAgeTogeUF4aXNcbiAgICB9LFxuICAgIGdyaWRsaW5lczogeUdyaWRsaW5lc1xufVxufSlcbiIpKSxtZHgoImhyIixudWxsKSxtZHgoImgxIix7ImlkIjoic2Vjb250aW9uLTUtbWFraW5nLXRoZS1jaGFydC1pbnRlcmFjdGl2ZSJ9LCJTZWNvbnRpb24gNTogTWFraW5nIHRoZSBDaGFydCBJbnRlcmFjdGl2ZSIpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIlNvcnRpbmcgZGF0YSB1c2luZyB0aGluZ3MgbGlrZSBidXR0b25zLiIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJTaW1pbGFyeSB0byBqcXVlcnksIHdpdGggaGF2ZSBkMyBtZXRob2RzIGxpa2UgXCJvblwiIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIlVzaW5nIHRoZSAnKycgcHJlZml4IHdpbGwgY29udmVydCB0aGUgc3RyaW5nIHRvIGEgbnVtYmVyIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIlRvIHNob3cgdXBkYXRlZCAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6ImxpIn0sImRhdGEiKSwiIGNoYW5nZXMsIHdlIG5lZWQgdG8ga25vdyBhYm91dCB0aGUgcGhhc2VzIC8vIGVudGVyKCksIHVwZGF0ZSgpLCBleGl0KCkiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwid2UgZW5zdXJlIHRoaXMgY2FuIGhhcHBlbiBieSBzcGxpdHRpbmcgdGhlIHNlbGVjdEFsbCBmdW5jdGlvbiB3aGVyZSB0aGUgdXBkYXRlZCBwaGFzZSBpcyBpbiB0aGUgbGF0dGVyIHBhcnQgLSB0aGVuIGluIHRoZSBleGl0IHBoYXNlIHdlIGdldCByaWQgb2YgYW55IGVsZW1lbnRzIHRoYXQgYXJlIG5vIGxvbmdlciBib3VuZCEiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwieW91IG11c3QgdXBkYXRlIHRoZSBkb21haW5zIHdoZW4geW91IHVwZGF0ZSBkYXRhISIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiLy8gZG8gZm9yIGFsbCBlbGVtZW50cyB3ZSB3aXNoIHRvIHJlbW92ZVxudGhpcy5zZWxlY3RBbGwoJy5iYXInKVxuICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgIC5leGl0KClcbiAgICAucmVtb3ZlKCk7XG4iKSkpO31pZih0eXBlb2YgTURYQ29udGVudCE9PSd1bmRlZmluZWQnJiZNRFhDb250ZW50JiZNRFhDb250ZW50PT09T2JqZWN0KE1EWENvbnRlbnQpJiZPYmplY3QuaXNFeHRlbnNpYmxlKE1EWENvbnRlbnQpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoTURYQ29udGVudCwnX19maWxlbWV0YScse2VudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZSx2YWx1ZTp7bmFtZToiTURYQ29udGVudCIsZmlsZW5hbWU6Im1hbnVhbC9KYXZhU2NyaXB0L0pTLUQzLVVkZW15Lm1kIn19KTt9TURYQ29udGVudC5pc01EWENvbXBvbmVudD10cnVlOw=="},{"version":3,"sources":["/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/JavaScript/JS-D3-Udemy.md"],"names":["React","mdx","makeShortcode","name","MDXDefaultShortcode","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":"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","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h2 {...{\n      \"id\": \"reading-the-d3-documentation\"\n    }}>{`Reading the D3 Documentation`}</h2>\n    {\n      /* TOC */\n    }\n    <pre><code parentName=\"pre\" {...{}}>{`- [Reading the D3 Documentation](#reading-the-d3-documentation)\n- [map() and filter() methods](#map-and-filter-methods)\n- [d3 methods](#d3-methods)\n- [Programmatic SVGs](#programmatic-svgs)\n- [Scaling Data](#scaling-data)\n- [Styling with CSS](#styling-with-css)\n- [Adding Text to the chart](#adding-text-to-the-chart)\n- [Using SVG groups](#using-svg-groups)\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#section-4-making-a-complex-chart\"\n        }}>{`Section 4: Making a Complex Chart`}</a><ul parentName=\"li\">\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#working-with-arrays-of-objects\"\n            }}>{`Working with Arrays of Objects`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#creating-an-ordinal-scale\"\n            }}>{`Creating an Ordinal Scale`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#setting-colour-with-colour-scales\"\n            }}>{`Setting colour with colour scales`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#adding-x-and-y-axis\"\n            }}>{`Adding X and Y axis`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#flipping-the-axes\"\n            }}>{`Flipping the axes`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#adding-gridlines\"\n            }}>{`Adding Gridlines`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#rotating-the-x-axis-titles\"\n            }}>{`Rotating the X axis titles`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#adding-axis-labels\"\n            }}>{`Adding axis labels`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#updating-the-plot-function-with-best-practises\"\n            }}>{`Updating the plot function with best practises`}</a></li>\n        </ul></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#secontion-5-making-the-chart-interactive\"\n        }}>{`Secontion 5: Making the Chart Interactive`}</a></li>\n    </ul>\n    {\n      /* /TOC */\n    }\n    <ul>\n      <li parentName=\"ul\">{`API Documentation is a great link to bookmark`}</li>\n    </ul>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"map-and-filter-methods\"\n    }}>{`map() and filter() methods`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [123, 52, 46, 30, 4];\n\nconst results = data.filter((entry) => {\n    return entry > 50;\n});\n\nconst mapping = data.map((entry) => {\n    console.log(entry.key);\n    console.log(entry.value);\n});\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"d3-methods\"\n    }}>{`d3 methods`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`const example = d3.min(data);\nconsole.log(example);       // values returned\n\nconst dataLoHiValue = d3.extent(data);  // return min/max as array\n\nvar dictMinValue = d3.min(dounts, (d, i) {\n    return d.value;\n});\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"programmatic-svgs\"\n    }}>{`Programmatic SVGs`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [132,71,337,93,78,43,20,16,30,8,17,21];\nlet svg = d3.select('body').append('svg')\n                .attr('id', 'chart')\n                .attr('height', 450)\n                .attr('width', 800);\n\n// creating the bars\n// vertical bar graph\nsvg.selectAll('.bar')\n    .data(data)\n    .enter()                // enter phase\n    .append('rect')\n    .attr('class', 'bar')   // for future selections\n    .attr('x', 0)\n    .attr('y', (d i) => {\n        return i * 20;\n    })\n    .attr('width', (d, i) => {\n        return d;\n    })\n    .attr('height', 19);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"scaling-data\"\n    }}>{`Scaling Data`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Creating scaling functions for both x and y.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [132, 71, 337, 93, 78, 43, 20, 16, 30, 8, 17, 21];\nlet w = 800;\nlet h = 450;\nlet x = d3.scale\n    .linear()\n    .domain([0, d3.max(data)])\n    .range([0, w]);\nlet y = d3.scale\n    .linear()\n    .domain([0, data.length])\n    .range([0, h]);\n\nlet svg = d3\n    .select('body')\n    .append('svg')\n    .attr('id', 'chart')\n    .attr('height', h)\n    .attr('width', w);\n\n// creating the bars\n// vertical bar graph\nsvg\n    .selectAll('.bar')\n    .data(data)\n    .enter() // enter phase\n    .append('rect')\n    .attr('class', 'bar') // for future selections\n    .attr('x', 0)\n    .attr('y', (d, i) => {\n        return y(i);\n    })\n    .attr('width', (d, i) => {\n        return x(d); // x() does the scaling\n    })\n    .attr('height', (d, i) => {\n        return y(1) - 1;\n    });\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"styling-with-css\"\n    }}>{`Styling with CSS`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Getting rid of the aliasing`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-css\"\n      }}>{`.bar {\n    fill: purple;\n}\n`}</code></pre>\n    <p>{`Not that `}<inlineCode parentName=\"p\">{`attr('class', 'bar')`}</inlineCode>{` will manually reset the class value, so you can also use `}<inlineCode parentName=\"p\">{`.classed('bar', true)`}</inlineCode>{` - true to add the class, false to remove.`}</p>\n    <h2 {...{\n      \"id\": \"adding-text-to-the-chart\"\n    }}>{`Adding Text to the chart`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Creating scaling functions for both x and y.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [132, 71, 337, 93, 78, 43, 20, 16, 30, 8, 17, 21];\nlet w = 800;\nlet h = 450;\nlet x = d3.scale\n    .linear()\n    .domain([0, d3.max(data)])\n    .range([0, w]);\nlet y = d3.scale\n    .linear()\n    .domain([0, data.length])\n    .range([0, h]);\n\nlet svg = d3\n    .select('body')\n    .append('svg')\n    .attr('id', 'chart')\n    .attr('height', h)\n    .attr('width', w);\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter() // enter phase\n        .append('rect')\n        .attr('class', 'bar') // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('width', (d, i) => {\n            return x(d); // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y(1) - 1;\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d); // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('dy', (d, i) => {\n            return y(1) / 1.5 + 2;\n        })\n        .text((d, i) => {\n            return d;\n        });\n}\n\n// first arg will be what is referenced by \"this\"\nplot.call(svg, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"using-svg-groups\"\n    }}>{`Using SVG groups`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`SVG groups are like a div that are a convenience element to allow children to be moved and affected together.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [132, 71, 337, 93, 78, 43, 20, 16, 30, 8, 17, 21];\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale\n    .linear()\n    .domain([0, d3.max(data)])\n    .range([0, width]);\nlet y = d3.scale\n    .linear()\n    .domain([0, data.length])\n    .range([0, height]);\n\nlet svg = d3\n    .select('body')\n    .append('svg')\n    .attr('id', 'chart')\n    .attr('height', h)\n    .attr('width', w);\n\nlet chart = svg\n    .append('g')\n    .classed('display', true)\n    .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter() // enter phase\n        .append('rect')\n        .attr('class', 'bar') // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('width', (d, i) => {\n            return x(d); // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y(1) - 1;\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d); // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('dy', (d, i) => {\n            return y(1) / 1.5 + 2;\n        })\n        .text((d, i) => {\n            return d;\n        });\n}\n\n// first arg will be what is referenced by \"this\"\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <hr></hr>\n    <h1 {...{\n      \"id\": \"section-4-making-a-complex-chart\"\n    }}>{`Section 4: Making a Complex Chart`}</h1>\n    <h2 {...{\n      \"id\": \"working-with-arrays-of-objects\"\n    }}>{`Working with Arrays of Objects`}</h2>\n    <p>{`If working with a dict, we need an accessor function!`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [\n    { key: 'Glazed', value: 132 },\n    { key: 'Jelly', value: 71 },\n    { key: 'Holes', value: 337 },\n    { key: 'Sprinkles', value: 93 },\n    { key: 'Crumb', value: 78 },\n    { key: 'Chocolate', value: 43 },\n    { key: 'Coconut', value: 20 },\n    { key: 'Cream', value: 16 },\n    { key: 'Cruller', value: 30 },\n    { key: 'clair', value: 8 },\n    { key: 'Fritter', value: 17 },\n    { key: 'Bearclaw', value: 21 }\n];\n\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale\n    .linear()\n    .domain([\n        0,\n        d3.max(data, (d) => {\n            return d.value;\n        })\n    ])\n    .range([0, width]);\n\nlet y = d3.scale\n    .linear()\n    .domain([0, data.length])\n    .range([0, height]);\n\nlet svg = d3\n    .select('body')\n    .append('svg')\n    .attr('width', 800)\n    .attr('height', 420)\n    .attr('id', 'chart');\nlet chart = svg\n    .append('g')\n    .classed('display', true)\n    .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter() // enter phase\n        .append('rect')\n        .attr('class', 'bar') // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value); // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y(1) - 1;\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value); // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('dy', (d, i) => {\n            return y(1) / 1.5 + 2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n}\n\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"creating-an-ordinal-scale\"\n    }}>{`Creating an Ordinal Scale`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`var data = [\n    {key: \"Glazed\",     value: 132},\n    {key: \"Jelly\",      value: 71},\n    {key: \"Holes\",      value: 337},\n    {key: \"Sprinkles\",  value: 93},\n    {key: \"Crumb\",      value: 78},\n    {key: \"Chocolate\",  value: 43},\n    {key: \"Coconut\",    value: 20},\n    {key: \"Cream\",      value: 16},\n    {key: \"Cruller\",    value: 30},\n    {key: \"clair\",     value: 8},\n    {key: \"Fritter\",    value: 17},\n    {key: \"Bearclaw\",   value: 21}\n];\n\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale.linear()\n        .domain([0, d3.max(data, (d) => {\n            return d.value;\n    })])\n        .range([0, width]);\nvar y = d3.scale.ordinal()          // need distinct values eg keys\n        .domain(data.map((entry) => {\n            return entry.key;\n        }))\n        .rangeBands([0, height]);   // used for distinct values\n\nlet svg = d3.select('body').append('svg')\n                        .attr('width', 800)\n            .attr('height', 420)\n            .attr('id', 'chart');\nlet chart = svg.append('g')\n                .classed('display', true)\n        .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter()                // enter phase\n        .append('rect')\n        .attr('class', 'bar')   // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value);      // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y.rangeBand() - 1;\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value);          // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('dy', (d, i) => {\n            return y.rangeBand()/1.5+2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n}\n\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"setting-colour-with-colour-scales\"\n    }}>{`Setting colour with colour scales`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`var data = [\n    {key: \"Glazed\",     value: 132},\n    {key: \"Jelly\",      value: 71},\n    {key: \"Holes\",      value: 337},\n    {key: \"Sprinkles\",  value: 93},\n    {key: \"Crumb\",      value: 78},\n    {key: \"Chocolate\",  value: 43},\n    {key: \"Coconut\",    value: 20},\n    {key: \"Cream\",      value: 16},\n    {key: \"Cruller\",    value: 30},\n    {key: \"clair\",     value: 8},\n    {key: \"Fritter\",    value: 17},\n    {key: \"Bearclaw\",   value: 21}\n];\n\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale.linear()\n        .domain([0, d3.max(data, (d) => {\n            return d.value;\n    })])\n        .range([0, width]);\nvar y = d3.scale.ordinal()          // need distinct values eg keys\n        .domain(data.map((entry) => {\n            return entry.key;\n        }))\n        .rangeBands([0, height]);   // used for distinct values\n\n// alter colours using linear scale\nlet linearColorScale = d3.scale.linear()\n                        .domain([0, data.length])\n                        .range(['#572500', '#F68026']);\n\n// ordinal for distinct colours\nlet ordinalColorScale = d3.scale.category20();\n\nlet svg = d3.select('body').append('svg')\n                        .attr('width', 800)\n            .attr('height', 420)\n            .attr('id', 'chart');\nlet chart = svg.append('g')\n                .classed('display', true)\n        .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter()                // enter phase\n        .append('rect')\n        .attr('class', 'bar')   // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value);      // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y.rangeBand() - 1;\n        })\n        .style('fill', (d, i) => {\n            return linearColorScale(i);\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value);          // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('dy', (d, i) => {\n            return y.rangeBand()/1.5+2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n}\n\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"adding-x-and-y-axis\"\n    }}>{`Adding X and Y axis`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`// after the colour scales\n\nlet xAxis = d3.svg.axis()           // svg portion of the d3 library\n                .scale(x)\n                .orient('bottom');\n\nlet yAxis = d3.svg.axis()\n                .scale(y)\n                .orient('left');\n\n...\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter()                // enter phase\n        .append('rect')\n        .attr('class', 'bar')   // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value);      // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y.rangeBand() - 1;\n        })\n        .style('fill', (d, i) => {\n            return linearColorScale(i);\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value);          // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('dy', (d, i) => {\n            return y.rangeBand()/1.5+2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n    this.append('g')\n            .classed('x axis', true)\n            .attr('transform', 'translate(' + 0  + ', ' + height  + ')')\n            .call(xAxis);\n    this.append('g')\n            .classed('y axis', true)\n            .attr('transform', 'translate(0, 0)')\n            .call(yAxis);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"flipping-the-axes\"\n    }}>{`Flipping the axes`}</h2>\n    <p>{`How to create a column chart?`}</p>\n    <ul>\n      <li parentName=\"ul\">{`height needs to take an offset`}</li>\n      <li parentName=\"ul\">{`other values essentially invert`}</li>\n      <li parentName=\"ul\">{`text anchor will be `}<inlineCode parentName=\"li\">{`middle`}</inlineCode>{` in css`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`var data = [\n    {key: \"Glazed\",     value: 132},\n    {key: \"Jelly\",      value: 71},\n    {key: \"Holes\",      value: 337},\n    {key: \"Sprinkles\",  value: 93},\n    {key: \"Crumb\",      value: 78},\n    {key: \"Chocolate\",  value: 43},\n    {key: \"Coconut\",    value: 20},\n    {key: \"Cream\",      value: 16},\n    {key: \"Cruller\",    value: 30},\n    {key: \"clair\",     value: 8},\n    {key: \"Fritter\",    value: 17},\n    {key: \"Bearclaw\",   value: 21}\n];\n\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale.ordinal()          // need distinct values eg keys\n        .domain(data.map((entry) => {\n            return entry.key;\n        }))\n        .rangeBands([0, height]);   // used for distinct values\n\nlet y = d3.scale.linear()\n        .domain([0, d3.max(data, (d) => {\n            return d.value;\n        })])\n        .range([height, 0]);    // IMPORTANT CHANGE FROM [0, width]\n\n// alter colours using linear scale\nlet linearColorScale = d3.scale.linear()\n                        .domain([0, data.length])\n                        .range(['#572500', '#F68026']);\n\n// ordinal for distinct colours\nlet ordinalColorScale = d3.scale.category20();\n\nlet svg = d3.select('body').append('svg')\n                        .attr('width', 800)\n            .attr('height', 420)\n            .attr('id', 'chart');\nlet chart = svg.append('g')\n                .classed('display', true)\n        .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter()                // enter phase\n        .append('rect')\n        .attr('class', 'bar')   // for future selections\n        .attr('x', (d, i) => {\n            return x(d.key);\n        })\n        .attr('y', (d, i) => {\n            return y(d.value);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value);      // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return x.rangeBand();\n        })\n        .style('fill', (d, i) => {\n            return linearColorScale(i);\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value);          // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('dy', (d, i) => {\n            return y.rangeBand()/1.5+2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n\n        this.append('g')\n            .classed('x axis', true)\n            .attr('transform', 'translate(' + 0  + ', ' + height  + ')')\n            .call(xAxis);\n        this.append('g')\n            .classed('y axis', true)\n            .attr('transform', 'translate(0, 0)')\n            .call(yAxis);\n}\n\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"adding-gridlines\"\n    }}>{`Adding Gridlines`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`var yGridlines = d3.svg.axis()              // create another \"axis\"\n                    .scale(y)\n                    .tickSize(-width, 0, 0)             // used to adjust the axis\n                    .tickFormat('')\n                    .orient('left');\n\n// add these grid lines with the call function at the start of the plot function\n`}</code></pre>\n    <p>{`The grid lines also need to be styled! Hit up the CSS file to do this.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`.gridline path,\n.gridline line {\n    fill: none;\n    color: blue;\n    shape-rendering: crispEdges;\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"rotating-the-x-axis-titles\"\n    }}>{`Rotating the X axis titles`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`...\nthis.append('g')\n            .classed('x axis', true)\n            .attr('transform', 'translate(' + 0  + ', ' + height  + ')')\n            .call(xAxis)\n                .selectAll('text')\n                    .style('text-anchor', 'end')\n                    .attr('dx', -8)\n                    .attr('dy', 8)\n                    .attr('transform', 'translate(0,0), rotate(-45)');\nthis.append('g')\n            .classed('y axis', true)\n            .attr('transform', 'translate(0, 0)')\n            .call(yAxis);\n...\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"adding-axis-labels\"\n    }}>{`Adding axis labels`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`// within the plot function at the bottom\n\nthis.select('.y.axis')\n    .append('text')\n    .attr('x', 0)\n    .attr('y', 0)\n    .style('text-anchor', 'middle')\n    .attr('transform', 'translate(-50, ' + height / 2 + ') rotate(-90)')\n    .text('Units sold');\n\nthis.select('.x.axis')\n    .append('text')\n    .attr('x', 0)\n    .attr('y', 0)\n    .style('text-anchor', 'middle')\n    .attr('transform', 'translate(' + width / 2 + ', 80) rotate(-90)')\n    .text('Donut Type');\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"updating-the-plot-function-with-best-practises\"\n    }}>{`Updating the plot function with best practises`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Add new parameter entries.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`plot.call(chart, {\n    data: data,\n    axis: {\n        x: xAxis,\n        y: yAxis\n    },\n    gridlines: yGridlines\n}\n})\n`}</code></pre>\n    <hr></hr>\n    <h1 {...{\n      \"id\": \"secontion-5-making-the-chart-interactive\"\n    }}>{`Secontion 5: Making the Chart Interactive`}</h1>\n    <ul>\n      <li parentName=\"ul\">{`Sorting data using things like buttons.`}</li>\n      <li parentName=\"ul\">{`Similary to jquery, with have d3 methods like \"on\"`}</li>\n      <li parentName=\"ul\">{`Using the '+' prefix will convert the string to a number`}</li>\n      <li parentName=\"ul\">{`To show updated `}<inlineCode parentName=\"li\">{`data`}</inlineCode>{` changes, we need to know about the phases // enter(), update(), exit()`}</li>\n      <li parentName=\"ul\">{`we ensure this can happen by splitting the selectAll function where the updated phase is in the latter part - then in the exit phase we get rid of any elements that are no longer bound!`}</li>\n      <li parentName=\"ul\">{`you must update the domains when you update data!`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`// do for all elements we wish to remove\nthis.selectAll('.bar')\n    .data(params.data)\n    .exit()\n    .remove();\n`}</code></pre>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "]}]}