# Architectural Design Patterns

## Layered Architecture Patterns

### Client/server pattern

Obvious one is the client/server pattern.

![Client-server pattern](/assets/software-architect/client-server-pattern.svg)

- Distinct client and server
- Separated by network
- Communication protocol
- Many clients, one server

Example clients are many browsers, mobile, etc.

Pros:

- Very secure
- Simple communication
- Centralized control
- Easy to manage

Cons:

- Requires network
- Difficult to scale out
- Single point of failure
- Hard to debug

### Layered pattern

![Layered pattern](/assets/software-architect/layered-pattern.svg)

- Strict areas of concern
- Layers may only communicate with peers above/below

Pros:

- High abstraction
- High isolation
- Structured communication
- Easy to scale out

Cons:

- Deep call chains
- Can hide complexity
- May harm performance
- Lowest layer must cover all use cases

### N-Tier Patterns

- Similar to layered pattern but on different servers.
- Usually 3 tiers
- Communication between layers uses network

Pros:

- High abstraction
- High isolation
- Structured communication
- Easy to scale out

Cons:

- Network = point of failure
- Network may be slow (can be bottlenecks)
- Coarse interfaces
- Hard to debug

## Structural Architecture Patterns

Defines the structure of the architecture.

> "How do the lego blocks fit together?"

### Components-based pattern

Assumes the entire architecture is based on components. An "aggregation" of building blocks.

- Components are modular building blocks of software
- Grouped into areas of concern
- Clearly described interfaces
- Containers provide additional services (similar terminology to Kubernetes)

![Components-based pattern](/assets/software-architect/component-based-pattern.svg)

> The word "plugin" is generally a give-away for requiring components

Pros:

- Easy deployment
- Allows 3rd parties
- Promotes modularity
- Few unanticipated interactions

Cons:

- Coarse building blocks
- Can be expensive
- Initialization may be slow
- Harder to develop & maintain

### Object-oriented pattern

- Uses Classes
- Grouped into areas of concern
- Describes public members
- Uses inheritance, composition, aggregation and associations

Pros:

- Easy to understand
- Promotoes reuse
- East to test & debug
- Highly cohesive

Cons:

- Inheritance hard to get right (when you dictate it, something will go wrong that inheritance doesn't account for)
- Many unanticipated communications
- Too detailed

## Presentation Architecture Patterns

### MVC Pattern

Model-View-Controller. Familiar pattern for most.

- Designed for presentation layers.
- View handles output.
- Model handles data.
- Controller handles interaction.

Pros:

- Strict separation of concerns
- Scales well

Cons:

- High overhead
- Scattered code
- Hard to data-bind

### MVVM

Model-View-View Model

- Derived from MVC
- View handles output
- Model handles data
- View model is binding source

Pros:

- Strict separation of concerns
- Scales well
- Easy to data-bind

Cons:

- Loss of controller isolation
- High overhead
- Scattered code

## Service Architecture Patterns

### Service-Oriented pattern

- Discrete business services
- Use network to communicate
- HTTP, XML, Soap, Binary

![Service-Orientated Pattern](/assets/software-architect/service-oriented-pattern.svg)

> Services is just a component/class that can be called externally.

`Contract` is a public interface that can call into a service.

Pros:

- Business domain alignment
- High abstraction
- Discoverable, resilient
- Allows third parties (pay for access)
- Cross-platform

Cons:

- Clients must handle slow, offline network
- Coarse interfaces
- May harm performance
- Security issues

### Microservice pattern

- Service calling services
- Can use fast, private network
- Deployed on multiple servers
- Fine-grained as opposed to course grained

Pros:

- Modular
- Reduced abstraction
- Discoverability, resilience
- Can use fast network
- Less coarse interfaces

Cons:

- Must cope with slow, offline network
- More unanticipated communications
- Hard to do transactions
- Hard to test, debug, deploy

## Message Bus pattern

- Services connected to a shared data bus
- Uses messages for communication
- Supports discovery, failover

Pros:

- Easy to extend
- Simple communication
- Very flexible
- Easy to scale
- Easy discovery, failover

Cons:

- Bus = single point of failure
- Coarse communications
- Can be slow
- Hard to test, debug

## Hybrid Architecture Patterns

Assembing multiple patterns together. You can combine patterns (you do not need to choose between them).

Pattern example:

1. Components in layers
2. MVC in presentation layer
3. Objects inside components
